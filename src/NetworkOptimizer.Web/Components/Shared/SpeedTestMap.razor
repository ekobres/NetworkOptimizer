@using NetworkOptimizer.Storage.Models
@using NetworkOptimizer.Storage.Helpers
@using NetworkOptimizer.UniFi
@using NetworkOptimizer.UniFi.Models
@using NetworkOptimizer.Web.Models
@using NetworkOptimizer.Web.Services
@using NetworkOptimizer.Web.Components.Shared
@using NetworkOptimizer.Core.Helpers
@using Microsoft.JSInterop
@implements IDisposable
@inject IJSRuntime JS
@inject UniFiConnectionService ConnectionService

@if (HasAnyMapData)
{
    <div class="card speed-test-map-card">
        <div class="card-header">
            <h2 class="card-title">Speed / Coverage Map</h2>
            <div class="map-filters">
                <SpeedTestSearchFilter @bind-SearchFilter="searchFilter"
                                       OnSearch="OnSearchExecuted"
                                       ShowStatus="false"
                                       Placeholder="Filter by client device or AP..." />
                <button class="btn btn-sm @(ShowLan ? "btn-primary" : "btn-secondary")"
                        @onclick="() => ToggleFilter(true)">
                    LAN (@LanCount)
                </button>
                <button class="btn btn-sm @(ShowExternal ? "btn-primary" : "btn-secondary")"
                        @onclick="() => ToggleFilter(false)">
                    External (@ExternalCount)
                </button>
                <button class="btn btn-sm @(HighAccuracyOnly ? "btn-primary" : "btn-secondary")"
                        @onclick="ToggleAccuracyFilter"
                        title="Filter out low GPS accuracy results (>15m)">
                    ≤15m
                </button>
                @if (HasAnyApMarkers)
                {
                    <button class="btn btn-sm @(ShowApMarkers ? "btn-primary" : "btn-secondary")"
                            @onclick="ToggleApMarkers"
                            data-tooltip="Show/hide access point markers">
                        APs (@PlacedApCount)
                    </button>
                    <button class="btn btn-sm @(apEditMode ? "btn-warning" : "btn-secondary")"
                            @onclick="ToggleApEditMode"
                            data-tooltip="@(apEditMode ? "Done editing AP locations" : "Edit AP locations")">
                        @(apEditMode ? "Done" : PlacedApCount > 0 ? "Edit APs" : "Place APs")
                    </button>
                }
                <button class="btn btn-sm btn-secondary map-action-btn"
                        @onclick="FitToMarkers"
                        title="Fit map to all markers">
                    <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 3h6v6"/><path d="M9 21H3v-6"/><path d="M21 3l-7 7"/><path d="M3 21l7-7"/></svg>
                </button>
                <button class="btn btn-sm btn-secondary map-action-btn"
                        @onclick="RefreshMap"
                        title="Refresh results">
                    <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/><path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16"/><path d="M16 21h5v-5"/></svg>
                </button>
            </div>
        </div>
        <div class="card-body">
            <div class="map-container">
                <div id="@mapId" class="speed-test-map" style="@(MapHeight != null ? $"height: {MapHeight}" : "")"></div>
                @if (ShowNoResultsMessage)
                {
                    <div class="map-no-results-overlay">
                        <div class="map-no-results-message">
                            <span>No results matching "@searchFilter"</span>
                            <button class="btn btn-sm btn-secondary" @onclick="ClearSearchFilter">Clear filter</button>
                        </div>
                    </div>
                }
                @if (apEditMode)
                {
                    @if (UnplacedAps.Any())
                    {
                        <div class="map-ap-panel">
                            <div class="map-ap-panel-header">
                                @if (selectedApForPlacement != null)
                                {
                                    <span>Click the map to place <strong>@selectedApForPlacement.Name</strong></span>
                                }
                                else
                                {
                                    <span>Select an AP to place on the map</span>
                                }
                            </div>
                            <div class="map-ap-panel-list">
                                @foreach (var ap in UnplacedAps)
                                {
                                    <button class="map-ap-item @(selectedApForPlacement?.Mac == ap.Mac ? "selected" : "")"
                                            @onclick="() => SelectApForPlacement(ap)">
                                        <img src="@(DeviceIcon.GetIconPath(ap.Model) ?? "/images/devices/default-ap.png")"
                                             alt="@ap.Model" class="map-ap-item-icon" />
                                        <span class="map-ap-item-name">@ap.Name</span>
                                    </button>
                                }
                            </div>
                        </div>
                    }
                    else
                    {
                        <div class="map-edit-hint">
                            Drag APs to adjust their locations
                        </div>
                    }
                }
                @if (!string.IsNullOrEmpty(selectedApMacFilter))
                {
                    var apName = ApMarkers.FirstOrDefault(a => a.Mac.Equals(selectedApMacFilter, StringComparison.OrdinalIgnoreCase))?.Name ?? "AP";
                    <div class="map-ap-filter-chip" @onclick="ClearApFilter">
                        @apName test results <span class="map-chip-close">&times;</span>
                    </div>
                }
            </div>
            <div class="map-footer">
                <div class="map-legend">
                    <span class="legend-item"><span class="legend-dot" style="background: #ef4444;"></span>&lt;50 Mbps</span>
                    <span class="legend-item"><span class="legend-dot" style="background: #facc15;"></span>50-200</span>
                    <span class="legend-item"><span class="legend-dot" style="background: #84cc16;"></span>200-500</span>
                    <span class="legend-item"><span class="legend-dot" style="background: #22c55e;"></span>&gt;500 Mbps</span>
                </div>
                <div class="map-time-slider">
                    <input type="range" min="0" max="10" step="1" @bind="sliderValue" @bind:after="OnSliderChanged" />
                    <span class="time-label">@GetTimeLabel()</span>
                </div>
            </div>
        </div>
    </div>
}

@code {
    [Parameter]
    public IEnumerable<Iperf3Result> Results { get; set; } = Enumerable.Empty<Iperf3Result>();

    [Parameter]
    public EventCallback OnRefresh { get; set; }

    [Parameter]
    public EventCallback<int> OnResultClick { get; set; }

    [Parameter]
    public IEnumerable<ApMapMarker> ApMarkers { get; set; } = Enumerable.Empty<ApMapMarker>();

    [Parameter]
    public EventCallback<(string Mac, double Lat, double Lng)> OnApLocationChanged { get; set; }

    [Parameter]
    public bool ClientDetailMode { get; set; }

    [Parameter]
    public bool ShowDashboardLinks { get; set; }

    [Parameter]
    public EventCallback<string> OnClientClick { get; set; }

    [Parameter]
    public string? MapHeight { get; set; }

    // Search filter state (internal to map only)
    private string searchFilter = "";

    private string mapId = $"map-{Guid.NewGuid():N}";
    private DotNetObjectReference<SpeedTestMap>? dotNetRef;
    private bool mapInitialized = false;

    // Demo mode: hide street labels on map
    private static bool IsDemoMode => !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("DEMO_MODE_MAPPINGS"));

    private bool userHasZoomed = false; // Track if user manually zoomed/panned
    private bool initialSetupComplete = false; // Ignore zoom events during initial setup
    private bool apEditMode = false; // Internal AP edit mode toggle
    private bool ShowApMarkers { get; set; } = true; // AP layer visibility
    private ApMapMarker? selectedApForPlacement = null; // AP selected for click-to-place
    private string? selectedApMacFilter = null; // AP MAC to filter speed tests by (null = show all)

    // Unplaced APs that need to be positioned on the map
    private IEnumerable<ApMapMarker> UnplacedAps => ApMarkers.Where(a => !a.Latitude.HasValue || !a.Longitude.HasValue);
    private bool ShowLan { get; set; } = true;
    private bool ShowExternal { get; set; } = false;
    private bool HighAccuracyOnly { get; set; } = false;
    private int lastResultCount = 0;
    private int? lastNewestResultId = null;
    private int lastApMarkerCount = 0;
    private List<NetworkInfo>? _networks;

    // Time slider: log scale breakpoints (slider value -> hours, 0 = all time)
    private static readonly (int hours, string label)[] TimeBreakpoints = new[]
    {
        (1, "1 hr"),         // 0
        (4, "4 hrs"),        // 1
        (24, "24 hrs"),      // 2
        (72, "3 days"),      // 3
        (168, "1 week"),     // 4
        (336, "2 weeks"),    // 5
        (720, "30 days"),    // 6
        (2160, "90 days"),   // 7
        (4320, "6 months"),  // 8
        (8760, "1 year"),    // 9
        (0, "All time")      // 10
    };
    private int sliderValue = 6; // Default to 30 days (index 6)

    // All tests with valid location data, filtered by time slider and search
    private IEnumerable<Iperf3Result> LocationResults
    {
        get
        {
            var results = Results
                .Where(r => r.Latitude.HasValue && r.Longitude.HasValue)
                .Where(r => !HighAccuracyOnly || (r.LocationAccuracyMeters.HasValue && r.LocationAccuracyMeters.Value <= 15));

            // Apply time filter from slider (0 = all time)
            var hours = TimeBreakpoints[sliderValue].hours;
            if (hours > 0)
            {
                var cutoff = DateTime.UtcNow.AddHours(-hours);
                results = results.Where(r => r.TestTime >= cutoff);
            }

            // Apply search filter (client + AP only for map view)
            if (!string.IsNullOrWhiteSpace(searchFilter))
            {
                var normalizedFilter = searchFilter.Trim().ToLowerInvariant();
                results = results.Where(r => SpeedTestFilterHelper.MatchesFilter(r, normalizedFilter, clientAndApOnly: true));
            }

            return results;
        }
    }

    // LAN = has valid L2 path, NOT external, AND has Wi-Fi signal (excludes wired clients)
    private IEnumerable<Iperf3Result> LanResults => LocationResults
        .Where(r => r.PathAnalysis?.Path?.IsValid == true
                    && r.PathAnalysis?.Path?.IsExternalPath != true
                    && r.WifiSignalDbm.HasValue);

    // External = no valid path OR is external path (VPN, Tailscale, Teleport, WAN)
    // Keeps backwards compatibility for old tests without path analysis
    private IEnumerable<Iperf3Result> ExternalResults => LocationResults
        .Where(r => r.PathAnalysis?.Path?.IsValid != true
                    || r.PathAnalysis?.Path?.IsExternalPath == true);

    private int LanCount => LanResults.Count();
    private int ExternalCount => ExternalResults.Count();

    // Filtered results based on toggle state
    private IEnumerable<Iperf3Result> FilteredResults
    {
        get
        {
            var results = Enumerable.Empty<Iperf3Result>();
            if (ShowLan) results = results.Concat(LanResults);
            if (ShowExternal) results = results.Concat(ExternalResults);

            // Filter by selected AP if one is active
            if (!string.IsNullOrEmpty(selectedApMacFilter))
            {
                results = results.Where(r =>
                    r.PathAnalysis?.Path?.Hops?.Any(h =>
                        h.Type == HopType.AccessPoint &&
                        h.DeviceMac.Equals(selectedApMacFilter, StringComparison.OrdinalIgnoreCase)) == true);
            }

            return results;
        }
    }

    // Check raw results for any location data (not filtered) - determines if map card shows at all
    private bool HasAnyLocationData => Results.Any(r => r.Latitude.HasValue && r.Longitude.HasValue);

    // Whether there are any AP markers (placed or unplaced) passed to this component
    private bool HasAnyApMarkers => ApMarkers.Any();

    // Count of APs with saved locations
    private int PlacedApCount => ApMarkers.Count(a => a.Latitude.HasValue && a.Longitude.HasValue);

    // Show map if we have speed test location data OR placed AP markers
    private bool HasAnyMapData => HasAnyLocationData || HasAnyApMarkers;

    // Check if current filter/time settings return any results (for "no results" message)
    private bool HasFilteredResults => FilteredResults.Any();

    // Check if search filter is active but returned no results
    private bool ShowNoResultsMessage => !string.IsNullOrEmpty(searchFilter) && !HasFilteredResults;

    private async Task ToggleFilter(bool isLan)
    {
        if (isLan)
            ShowLan = !ShowLan;
        else
            ShowExternal = !ShowExternal;

        // Ensure at least one is selected
        if (!ShowLan && !ShowExternal)
        {
            if (isLan)
                ShowExternal = true;
            else
                ShowLan = true;
        }

        if (mapInitialized)
        {
            await UpdateMarkers(fitBounds: true);
        }
    }

    private async Task ToggleAccuracyFilter()
    {
        HighAccuracyOnly = !HighAccuracyOnly;

        if (mapInitialized)
        {
            await UpdateMarkers(fitBounds: true);
        }
    }

    private string GetTimeLabel() => TimeBreakpoints[sliderValue].label;

    private async Task OnSliderChanged()
    {
        // Time filter is applied internally via LocationResults property
        // Only fit bounds if user hasn't manually zoomed/panned
        if (mapInitialized)
        {
            await UpdateMarkers(fitBounds: !userHasZoomed);
        }
    }

    private async Task RefreshMap()
    {
        if (OnRefresh.HasDelegate)
        {
            await OnRefresh.InvokeAsync();
        }
    }

    private async Task FitToMarkers()
    {
        if (mapInitialized)
        {
            userHasZoomed = false; // Reset so slider will auto-fit again
            await UpdateMarkers(fitBounds: true);
        }
    }

    private async Task OnSearchExecuted(string filter)
    {
        // Update markers with new filter (map filter is independent of table)
        if (mapInitialized)
        {
            await UpdateMarkers(fitBounds: !userHasZoomed);
        }
        StateHasChanged();
    }

    private async Task ClearSearchFilter()
    {
        searchFilter = "";
        if (mapInitialized)
        {
            await UpdateMarkers(fitBounds: true);
        }
        StateHasChanged();
    }

    private async Task ToggleApMarkers()
    {
        ShowApMarkers = !ShowApMarkers;
        if (mapInitialized)
        {
            await UpdateApMarkers();
        }
    }

    private async Task ToggleApEditMode()
    {
        apEditMode = !apEditMode;
        selectedApForPlacement = null;
        if (mapInitialized)
        {
            await UpdateApMarkers();
            await SetMapClickToPlaceMode(apEditMode);
        }
    }

    private async Task SelectApForPlacement(ApMapMarker ap)
    {
        selectedApForPlacement = selectedApForPlacement?.Mac == ap.Mac ? null : ap;
        await UpdateMapCursor(selectedApForPlacement != null);
    }

    [JSInvokable]
    public async Task OnMapClickForPlacement(double lat, double lng)
    {
        if (selectedApForPlacement == null) return;

        var mac = selectedApForPlacement.Mac;
        selectedApForPlacement = null;

        // Fire the location changed event (parent saves to DB)
        if (OnApLocationChanged.HasDelegate)
        {
            await OnApLocationChanged.InvokeAsync((mac, lat, lng));
        }

        // Reset cursor and refresh AP markers
        await UpdateMapCursor(false);
        await InvokeAsync(async () =>
        {
            StateHasChanged();
            if (mapInitialized)
            {
                await UpdateApMarkers();
            }
        });
    }

    private async Task SetMapClickToPlaceMode(bool enabled)
    {
        if (!mapInitialized) return;

        var enableStr = enabled ? "true" : "false";
        await JS.InvokeVoidAsync("eval", $@"
            (function() {{
                const mapData = window._speedTestMaps && window._speedTestMaps['{mapId}'];
                if (!mapData || !mapData.map) return;

                // Remove existing click handler if any
                if (mapData._placementClickHandler) {{
                    mapData.map.off('click', mapData._placementClickHandler);
                    mapData._placementClickHandler = null;
                }}

                if ({enableStr}) {{
                    mapData._placementClickHandler = function(e) {{
                        if (mapData.dotNetRef) {{
                            mapData.dotNetRef.invokeMethodAsync('OnMapClickForPlacement', e.latlng.lat, e.latlng.lng);
                        }}
                    }};
                    mapData.map.on('click', mapData._placementClickHandler);
                }} else {{
                    mapData.map.getContainer().style.cursor = '';
                }}
            }})();
        ");
    }

    private async Task UpdateMapCursor(bool crosshair)
    {
        if (!mapInitialized) return;

        var cursor = crosshair ? "crosshair" : "";
        await JS.InvokeVoidAsync("eval", $@"
            (function() {{
                const mapData = window._speedTestMaps && window._speedTestMaps['{mapId}'];
                if (mapData && mapData.map) mapData.map.getContainer().style.cursor = '{cursor}';
            }})();
        ");
    }

    protected override async Task OnInitializedAsync()
    {
        // Load networks for VPN detection
        _networks = await ConnectionService.GetNetworksAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // Initialize map when we have any data (speed tests with location OR placed APs) and DOM is ready
        if (!mapInitialized && HasAnyMapData)
        {
            await InitializeMap();
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        var currentCount = Results.Count();
        var newestId = Results.FirstOrDefault()?.Id;

        // Update markers if data changed (count or newest result ID)
        if (mapInitialized && (currentCount != lastResultCount || newestId != lastNewestResultId))
        {
            lastResultCount = currentCount;
            lastNewestResultId = newestId;
            await UpdateMarkers(fitBounds: false);
            StateHasChanged();
        }

        // Update AP markers only when AP data actually changes
        if (mapInitialized)
        {
            var currentApCount = ApMarkers.Count();
            if (currentApCount != lastApMarkerCount)
            {
                lastApMarkerCount = currentApCount;
                await UpdateApMarkers();
            }
        }
    }

    private async Task InitializeMap()
    {
        try
        {
            // Create .NET object reference for JS callbacks
            dotNetRef = DotNetObjectReference.Create(this);

            // Dynamically load Leaflet if not present
            await JS.InvokeVoidAsync("eval", @"
                (function() {
                    function loadScript(src) {
                        return new Promise((resolve, reject) => {
                            const existing = document.querySelector('script[src=""' + src + '""]');
                            if (existing) {
                                // Script tag exists - wait for it to load if still loading
                                if (existing.dataset.loaded === 'true') {
                                    resolve(); return;
                                }
                                existing.addEventListener('load', () => resolve());
                                existing.addEventListener('error', () => reject());
                                return;
                            }
                            const s = document.createElement('script');
                            s.src = src;
                            s.onload = () => { s.dataset.loaded = 'true'; resolve(); };
                            s.onerror = reject;
                            document.head.appendChild(s);
                        });
                    }
                    function loadCss(href) {
                        if (document.querySelector('link[href=""' + href + '""]')) return;
                        const l = document.createElement('link');
                        l.rel = 'stylesheet';
                        l.href = href;
                        document.head.appendChild(l);
                    }

                    // Always load CSS
                    loadCss('https://unpkg.com/leaflet@1.9.4/dist/leaflet.css');
                    loadCss('https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css');
                    loadCss('https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css');

                    // If both are already loaded, skip
                    if (typeof L !== 'undefined' && typeof L.markerClusterGroup === 'function') {
                        return Promise.resolve();
                    }

                    // Load Leaflet first, then MarkerCluster (must be sequential)
                    return loadScript('https://unpkg.com/leaflet@1.9.4/dist/leaflet.js')
                        .then(() => loadScript('https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js'));
                })();
            ");

            // Poll until both Leaflet and MarkerCluster are ready (up to 3s)
            for (int i = 0; i < 30; i++)
            {
                var ready = await JS.InvokeAsync<bool>("eval", "typeof L !== 'undefined' && typeof L.markerClusterGroup === 'function'");
                if (ready) break;
                await Task.Delay(100);
            }

            // Initialize the map using inline JS
            await JS.InvokeVoidAsync("eval", $@"
                (function() {{
                    if (typeof L === 'undefined') return;
                    const container = document.getElementById('{mapId}');
                    if (!container) return;

                    window._speedTestMaps = window._speedTestMaps || {{}};
                    if (window._speedTestMaps['{mapId}']) return;

                    const map = L.map('{mapId}', {{ maxZoom: 22 }}).setView([39.8, -98.6], 4);
                    const isDemoMode = {IsDemoMode.ToString().ToLower()};
                    // Demo mode: use Voyager no-labels (better rendering than light_nolabels)
                    // CartoDB tiles only go to zoom 18, OSM goes to 19
                    const tileUrl = isDemoMode
                        ? 'https://{{s}}.basemaps.cartocdn.com/rastertiles/voyager_nolabels/{{z}}/{{x}}/{{y}}.png'
                        : 'https://{{s}}.tile.openstreetmap.org/{{z}}/{{x}}/{{y}}.png';
                    const tileAttribution = isDemoMode ? '© CartoDB © OpenStreetMap' : '© OpenStreetMap';
                    const maxNative = isDemoMode ? 18 : 19;
                    L.tileLayer(tileUrl, {{
                        maxZoom: 22,
                        maxNativeZoom: maxNative,
                        attribution: tileAttribution
                    }}).addTo(map);

                    // Custom panes for z-ordering (bottom to top):
                    // apGlowPane(390) < clusterPane(420) < apIconPane(450) < overlayPane(500) < markerPane(600)
                    map.createPane('apGlowPane');
                    map.getPane('apGlowPane').style.zIndex = 390;
                    map.createPane('clusterPane');
                    map.getPane('clusterPane').style.zIndex = 420;
                    map.createPane('apIconPane');
                    map.getPane('apIconPane').style.zIndex = 450;
                    // Raise overlayPane so individual speed test dots render above AP icons
                    map.getPane('overlayPane').style.zIndex = 500;

                    // Scale AP icons with zoom level (up to 25% larger at high zoom)
                    function updateApScale() {{
                        const zoom = map.getZoom();
                        const scale = Math.min(1.25, Math.max(1.0, 1.0 + (zoom - 20) * 0.125));
                        container.style.setProperty('--ap-scale', scale.toFixed(3));
                    }}
                    map.on('zoomend', updateApScale);
                    updateApScale();

                    // Speed color function for clusters
                    function getSpeedColor(speed) {{
                        if (speed < 50) return 'rgb(239,68,68)';
                        if (speed < 200) return 'rgb(250,204,21)';
                        if (speed < 500) return 'rgb(132,204,22)';
                        return 'rgb(34,197,94)';
                    }}

                    // Create marker cluster group with speed-based coloring
                    const clusterGroup = L.markerClusterGroup({{
                        clusterPane: 'clusterPane',
                        maxClusterRadius: 24,
                        spiderfyOnMaxZoom: true,
                        showCoverageOnHover: false,
                        zoomToBoundsOnClick: true,
                        iconCreateFunction: function(cluster) {{
                            const markers = cluster.getAllChildMarkers();
                            let totalSpeed = 0;
                            markers.forEach(m => {{ totalSpeed += m.options.speed || 0; }});
                            const avgSpeed = totalSpeed / markers.length;
                            const color = getSpeedColor(avgSpeed);

                            return L.divIcon({{
                                html: ""<div class='speed-cluster' style='background:"" + color + ""'>"" + markers.length + ""</div>"",
                                className: 'speed-cluster-icon',
                                iconSize: L.point(40, 40)
                            }});
                        }}
                    }});
                    map.addLayer(clusterGroup);

                    // Track switching state (currentSpider is initialized on mapData object below)
                    var switchingSpider = false;

                    // Fade out existing spider and set z-index on cluster click
                    clusterGroup.on('clusterclick', function(e) {{
                        const mapData = window._speedTestMaps['{mapId}'];
                        if (mapData.currentSpider) {{
                            switchingSpider = true;
                            var markers = mapData.currentSpider.getAllChildMarkers();
                            markers.forEach(m => {{
                                if (m._path) {{
                                    m._path.style.transition = 'opacity 0.2s ease-out';
                                    m._path.style.opacity = '0';
                                }}
                                if (m._spiderLeg && m._spiderLeg._path) {{
                                    m._spiderLeg._path.style.transition = 'opacity 0.2s ease-out';
                                    m._spiderLeg._path.style.opacity = '0';
                                }}
                            }});
                        }}
                        // Set z-index BEFORE spider opens
                        map.getPane('overlayPane').style.zIndex = 650;
                    }});

                    clusterGroup.on('spiderfied', function(e) {{
                        window._speedTestMaps['{mapId}'].currentSpider = e.cluster;
                        switchingSpider = false;
                        // Disable clicks on the spiderfied cluster icon
                        if (e.cluster._icon) {{
                            e.cluster._icon.style.pointerEvents = 'none';
                        }}
                        // Disable clicks on spider legs
                        var markers = e.cluster.getAllChildMarkers();
                        markers.forEach(m => {{
                            if (m._spiderLeg && m._spiderLeg._path) {{
                                m._spiderLeg._path.style.pointerEvents = 'none';
                            }}
                        }});
                    }});

                    clusterGroup.on('unspiderfied', function(e) {{
                        // Re-enable clicks on the cluster icon
                        if (e.cluster && e.cluster._icon) {{
                            e.cluster._icon.style.pointerEvents = '';
                        }}
                        // Re-enable clicks on spider legs
                        var markers = e.cluster.getAllChildMarkers();
                        markers.forEach(m => {{
                            if (m._spiderLeg && m._spiderLeg._path) {{
                                m._spiderLeg._path.style.pointerEvents = '';
                            }}
                        }});
                        window._speedTestMaps['{mapId}'].currentSpider = null;
                        // Only reset z-index if not switching to a new spider
                        if (!switchingSpider) {{
                            map.getPane('overlayPane').style.zIndex = 500;
                        }}
                    }});

                    // Use mousedown on container to fade spider when clicking outside
                    map.getContainer().addEventListener('mousedown', function(e) {{
                        const mapData = window._speedTestMaps['{mapId}'];
                        if (mapData.currentSpider) {{
                            var markers = mapData.currentSpider.getAllChildMarkers();
                            // Check if click is on a spider element - if so, don't fade
                            var clickedOnSpider = markers.some(m =>
                                e.target === m._path ||
                                (m._spiderLeg && e.target === m._spiderLeg._path)
                            );
                            if (clickedOnSpider) return;

                            // Check if click is on a popup - if so, don't fade
                            var clickedOnPopup = e.target.closest && e.target.closest('.leaflet-popup');
                            if (clickedOnPopup) return;

                            // Check if click is on another cluster - if so, let clusterclick handle it
                            var clickedOnCluster = e.target.closest && e.target.closest('.speed-cluster');
                            if (clickedOnCluster) return;

                            // Check if click is on an AP marker - if so, don't fade
                            var clickedOnAp = e.target.closest && e.target.closest('.ap-marker-icon');
                            if (clickedOnAp) return;

                            // Check if click is on any interactive marker (speed test dots, etc.)
                            if (e.target.classList && e.target.classList.contains('leaflet-interactive')) return;

                            // Fade out spider when clicking outside
                            markers.forEach(m => {{
                                if (m._path) {{
                                    m._path.style.transition = 'opacity 0.2s ease-out';
                                    m._path.style.opacity = '0';
                                }}
                                if (m._spiderLeg && m._spiderLeg._path) {{
                                    m._spiderLeg._path.style.transition = 'opacity 0.2s ease-out';
                                    m._spiderLeg._path.style.opacity = '0';
                                }}
                            }});
                        }}
                    }}, true);

                    // AP layers use custom panes for z-ordering
                    const apGlowGroup = L.layerGroup({{ pane: 'apGlowPane' }}).addTo(map);
                    const apLayerGroup = L.layerGroup({{ pane: 'apIconPane' }}).addTo(map);

                    window._speedTestMaps['{mapId}'] = {{ map: map, clusterGroup: clusterGroup, apGlowGroup: apGlowGroup, apLayerGroup: apLayerGroup, currentSpider: null }};
                }})();
            ");

            // Register click handler and zoom/drag listeners with .NET callback
            await JS.InvokeVoidAsync("eval", $@"
                window._registerSpeedTestMapCallback = function(dotNetRef, mapId) {{
                    window._speedTestMapClick = function(id) {{
                        dotNetRef.invokeMethodAsync('OnMapResultClick', id);
                    }};
                    window._speedTestApFocus = function(mac) {{
                        // Pan to AP and open its popup - don't activate the filter
                        var mapData = window._speedTestMaps && window._speedTestMaps[mapId];
                        if (mapData && mapData.apLayerGroup && mapData.map) {{
                            mapData.apLayerGroup.eachLayer(function(layer) {{
                                if (layer._apMac === mac) {{
                                    mapData.map.panTo(layer.getLatLng(), {{ animate: true }});
                                    setTimeout(function() {{ layer.openPopup(); }}, 300);
                                }}
                            }});
                        }}
                    }};
                    window._speedTestApFilterAndClose = function(mapId, mac) {{
                        dotNetRef.invokeMethodAsync('OnApMarkerClick', mac);
                        var mapData = window._speedTestMaps && window._speedTestMaps[mapId];
                        if (mapData && mapData.map) mapData.map.closePopup();
                    }};
                    window._speedTestClientClick = function(mac) {{
                        // Close popup and destroy tippy instances before navigating
                        var mapData = window._speedTestMaps && window._speedTestMaps[mapId];
                        if (mapData && mapData.map) mapData.map.closePopup();
                        document.querySelectorAll('[data-tippy-root]').forEach(function(el) {{ el.remove(); }});
                        dotNetRef.invokeMethodAsync('OnMapClientClick', mac);
                    }};

                    // Store .NET ref on map data for AP drag callbacks
                    var mapData = window._speedTestMaps && window._speedTestMaps[mapId];
                    if (mapData) {{
                        mapData.dotNetRef = dotNetRef;
                    }}

                    // Track user zoom/drag interactions
                    if (mapData && mapData.map) {{
                        var programmaticMove = false;
                        mapData.setProgrammaticMove = function(val) {{ programmaticMove = val; }};

                        mapData.map.on('zoomend dragend', function() {{
                            if (!programmaticMove) {{
                                dotNetRef.invokeMethodAsync('OnUserMapInteraction');
                            }}
                        }});
                    }}
                }};
            ");
            await JS.InvokeVoidAsync("_registerSpeedTestMapCallback", dotNetRef, mapId);

            // Verify the map was actually created (JS returns early if container not found)
            var mapCreated = await JS.InvokeAsync<bool>("eval", $"!!(window._speedTestMaps && window._speedTestMaps['{mapId}'])");
            if (!mapCreated)
            {
                // Trigger another render cycle to retry
                await Task.Delay(50);
                StateHasChanged();
                return;
            }

            mapInitialized = true;
            lastResultCount = Results.Count();
            lastNewestResultId = Results.FirstOrDefault()?.Id;
            await UpdateMarkers(fitBounds: true);
            await UpdateApMarkers();

            // Allow time for initial fitBounds animation to complete before tracking user interactions
            await Task.Delay(500);
            initialSetupComplete = true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Map init error: {ex.Message}");
        }
    }

    private async Task UpdateMarkers(bool fitBounds, bool fitIfNarrowing = false)
    {
        if (!mapInitialized) return;

        try
        {
            var markers = FilteredResults.Select(r => new
            {
                id = r.Id,
                lat = r.Latitude!.Value,
                lng = r.Longitude!.Value,
                speed = (r.DownloadMbps + r.UploadMbps) / 2,
                color = GetSpeedColor((r.DownloadMbps + r.UploadMbps) / 2),
                isExternal = r.PathAnalysis?.Path?.IsValid != true || r.PathAnalysis?.Path?.IsExternalPath == true,
                popup = BuildPopup(r, r.PathAnalysis?.Path?.IsValid != true || r.PathAnalysis?.Path?.IsExternalPath == true)
            }).ToArray();

            // Include AP positions as fallback bounds when no speed test dots exist
            var apBounds = ApMarkers
                .Where(a => a.Latitude.HasValue && a.Longitude.HasValue)
                .Select(a => new[] { a.Latitude!.Value, a.Longitude!.Value })
                .ToArray();

            var markersJson = System.Text.Json.JsonSerializer.Serialize(markers);
            var apBoundsJson = System.Text.Json.JsonSerializer.Serialize(apBounds);
            var shouldFitBounds = fitBounds ? "true" : "false";
            var shouldFitIfNarrowing = fitIfNarrowing ? "true" : "false";

            await JS.InvokeVoidAsync("eval", $@"
                (function() {{
                    const mapData = window._speedTestMaps && window._speedTestMaps['{mapId}'];
                    if (!mapData) return;

                    const map = mapData.map;
                    const clusterGroup = mapData.clusterGroup;

                    // Save state before clearing (open popup, spiderfied cluster)
                    let openPopupId = null;
                    let spiderfiedMarkerIds = [];

                    clusterGroup.eachLayer(layer => {{
                        if (layer.isPopupOpen && layer.isPopupOpen()) {{
                            openPopupId = layer.options.resultId;
                        }}
                    }});

                    if (mapData.currentSpider) {{
                        const childMarkers = mapData.currentSpider.getAllChildMarkers();
                        childMarkers.forEach(m => {{
                            spiderfiedMarkerIds.push(m.options.resultId);
                            if (m.isPopupOpen && m.isPopupOpen()) {{
                                openPopupId = m.options.resultId;
                            }}
                        }});
                    }}

                    clusterGroup.clearLayers();

                    const markers = {markersJson};
                    const bounds = [];
                    let markerToReopen = null;
                    const markerMap = {{}};

                    markers.forEach(m => {{
                        const marker = L.circleMarker([m.lat, m.lng], {{
                            radius: 8,
                            fillColor: m.color,
                            color: m.isExternal ? '#888' : '#fff',
                            weight: 2,
                            opacity: 1,
                            fillOpacity: 0.8,
                            speed: m.speed,
                            resultId: m.id
                        }});

                        marker.bindPopup(m.popup);
                        clusterGroup.addLayer(marker);
                        bounds.push([m.lat, m.lng]);
                        markerMap[m.id] = marker;

                        if (openPopupId && m.id === openPopupId) {{
                            markerToReopen = marker;
                        }}
                    }});

                    // Restore spider and/or popup
                    if (spiderfiedMarkerIds.length > 0) {{
                        setTimeout(() => {{
                            let clusterToSpiderfy = null;
                            for (const id of spiderfiedMarkerIds) {{
                                const marker = markerMap[id];
                                if (marker) {{
                                    const parent = clusterGroup.getVisibleParent(marker);
                                    if (parent && parent !== marker && parent.spiderfy) {{
                                        clusterToSpiderfy = parent;
                                        break;
                                    }}
                                }}
                            }}

                            if (clusterToSpiderfy) {{
                                clusterToSpiderfy.spiderfy();
                                if (openPopupId) {{
                                    setTimeout(() => {{
                                        const marker = markerMap[openPopupId];
                                        if (marker) marker.openPopup();
                                    }}, 100);
                                }}
                            }} else if (markerToReopen) {{
                                markerToReopen.openPopup();
                            }}
                        }}, 50);
                    }} else if (markerToReopen) {{
                        markerToReopen.openPopup();
                    }}

                    // Fall back to AP positions when no speed test dots
                    const apBounds = {apBoundsJson};
                    const fitTargets = bounds.length > 0 ? bounds : apBounds;

                    // Determine if we should fit bounds:
                    // 1. If explicitly requested (fitBounds=true), or
                    // 2. If fitIfNarrowing and the new bounds are inside the current view (zoom in only), or
                    // 3. If none of the filtered markers are visible in current view
                    let shouldActuallyFitBounds = {shouldFitBounds};
                    if (!shouldActuallyFitBounds && fitTargets.length > 0) {{
                        const currentBounds = map.getBounds();
                        if ({shouldFitIfNarrowing}) {{
                            // Only auto-fit if it would narrow (zoom in) the view
                            const newBounds = L.latLngBounds(fitTargets.map(b => L.latLng(b[0], b[1])));
                            if (currentBounds.contains(newBounds)) {{
                                shouldActuallyFitBounds = true;
                            }}
                        }}
                        // Always fit if all markers are off-screen (safety net)
                        if (!shouldActuallyFitBounds) {{
                            const anyVisible = fitTargets.some(b => currentBounds.contains(L.latLng(b[0], b[1])));
                            if (!anyVisible) {{
                                shouldActuallyFitBounds = true;
                            }}
                        }}
                    }}

                    if (shouldActuallyFitBounds && fitTargets.length > 0) {{
                        // Mark as programmatic so zoom/drag listeners don't fire
                        if (mapData.setProgrammaticMove) mapData.setProgrammaticMove(true);
                        if (fitTargets.length === 1) {{
                            map.setView(fitTargets[0], 18);
                        }} else {{
                            map.fitBounds(fitTargets, {{ padding: [20, 20], maxZoom: 22 }});
                        }}
                        // Reset after a short delay (after zoomend fires)
                        setTimeout(() => {{
                            if (mapData.setProgrammaticMove) mapData.setProgrammaticMove(false);
                        }}, 300);
                    }}

                    setTimeout(() => map.invalidateSize(), 100);
                }})();
            ");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Marker update error: {ex.Message}");
        }
    }

    private async Task UpdateApMarkers()
    {
        if (!mapInitialized) return;

        try
        {
            var placedAps = ShowApMarkers
                ? ApMarkers.Where(a => a.Latitude.HasValue && a.Longitude.HasValue).ToArray()
                : Array.Empty<ApMapMarker>();

            var apData = placedAps.Select(a => new
            {
                mac = a.Mac,
                lat = a.Latitude!.Value,
                lng = a.Longitude!.Value,
                name = a.Name,
                model = a.Model,
                isOnline = a.IsOnline,
                totalClients = a.TotalClients,
                iconUrl = DeviceIcon.GetIconPath(a.Model) ?? "/images/devices/default-ap.png",
                isSelected = a.Mac.Equals(selectedApMacFilter, StringComparison.OrdinalIgnoreCase),
                popup = BuildApPopup(a)
            }).ToArray();

            var apJson = System.Text.Json.JsonSerializer.Serialize(apData);
            var isDraggable = apEditMode ? "true" : "false";

            await JS.InvokeVoidAsync("eval", $@"
                (function() {{
                    const mapData = window._speedTestMaps && window._speedTestMaps['{mapId}'];
                    if (!mapData || !mapData.apLayerGroup) return;

                    mapData.apLayerGroup.clearLayers();
                    if (mapData.apGlowGroup) mapData.apGlowGroup.clearLayers();

                    const aps = {apJson};
                    const draggable = {isDraggable};

                    if (!mapData._apGlowByMac) mapData._apGlowByMac = {{}};

                    aps.forEach(ap => {{
                        // Glow layer in apGlowPane (behind everything)
                        if (mapData.apGlowGroup) {{
                            const glowIcon = L.divIcon({{
                                html: ""<div class='ap-glow-dot"" + (ap.isSelected ? "" ap-glow-selected"" : """") + ""'></div>"",
                                className: 'ap-glow-container',
                                iconSize: [48, 48],
                                iconAnchor: [24, 24]
                            }});
                            const glowMarker = L.marker([ap.lat, ap.lng], {{
                                icon: glowIcon,
                                interactive: false,
                                pane: 'apGlowPane'
                            }});
                            mapData.apGlowGroup.addLayer(glowMarker);
                            mapData._apGlowByMac[ap.mac.toLowerCase()] = glowMarker;
                        }}

                        // Icon layer in apIconPane (above clusters, below individual dots)
                        const icon = L.divIcon({{
                            html: ""<img src='"" + ap.iconUrl + ""' class='ap-marker-icon' style='opacity:"" + (ap.isOnline ? 1.0 : 0.4) + ""' />"",
                            className: 'ap-marker-container',
                            iconSize: [32, 32],
                            iconAnchor: [16, 16],
                            popupAnchor: [0, -16]
                        }});

                        const marker = L.marker([ap.lat, ap.lng], {{
                            icon: icon,
                            draggable: draggable,
                            pane: 'apIconPane'
                        }});

                        marker._apMac = ap.mac;
                        marker.bindPopup(ap.popup);

                        if (draggable) {{
                            marker.on('drag', function(e) {{
                                var gm = mapData._apGlowByMac && mapData._apGlowByMac[ap.mac.toLowerCase()];
                                if (gm) gm.setLatLng(e.target.getLatLng());
                            }});
                            marker.on('dragend', function(e) {{
                                const pos = e.target.getLatLng();
                                if (mapData.dotNetRef) {{
                                    mapData.dotNetRef.invokeMethodAsync('OnApDragEnd', ap.mac, pos.lat, pos.lng);
                                }}
                            }});
                        }}

                        // Highlight glow when popup is open (look up dynamically so it survives glow rebuilds)
                        marker.on('popupopen', function() {{
                            var gm = mapData._apGlowByMac && mapData._apGlowByMac[ap.mac.toLowerCase()];
                            if (gm) {{
                                var el = gm.getElement();
                                if (el) el.querySelector('.ap-glow-dot')?.classList.add('ap-glow-selected');
                            }}
                        }});
                        marker.on('popupclose', function() {{
                            if (mapData._selectedApMac && mapData._selectedApMac.toLowerCase() === ap.mac.toLowerCase()) return;
                            var gm = mapData._apGlowByMac && mapData._apGlowByMac[ap.mac.toLowerCase()];
                            if (gm) {{
                                var el = gm.getElement();
                                if (el) el.querySelector('.ap-glow-dot')?.classList.remove('ap-glow-selected');
                            }}
                        }});

                        mapData.apLayerGroup.addLayer(marker);
                    }});
                }})();
            ");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"AP marker update error: {ex.Message}");
        }
    }

    private string BuildApPopup(ApMapMarker ap)
    {
        var name = ap.Name?.Replace("'", "\\'").Replace("\"", "&quot;") ?? "Unknown AP";
        var model = ap.Model?.Replace("'", "\\'").Replace("\"", "&quot;") ?? "";
        var statusClass = ap.IsOnline ? "ap-status-online" : "ap-status-offline";
        var statusText = ap.IsOnline ? "Online" : "Offline";

        // Count speed tests connected to this AP
        var testCount = Results.Count(r =>
            r.PathAnalysis?.Path?.Hops?.Any(h =>
                h.Type == HopType.AccessPoint &&
                h.DeviceMac.Equals(ap.Mac, StringComparison.OrdinalIgnoreCase)) == true);

        var html = "<div class='map-popup ap-popup'>";

        // Header: status dot + name
        html += "<div class='wifi-tooltip-header'>";
        html += $"<span class='ap-status-dot {statusClass}'></span> {name}";
        html += "</div>";

        // Model + status subtitle
        if (!string.IsNullOrEmpty(model))
        {
            html += $"<div class='ap-popup-subtitle'>{model} - {statusText}</div>";
        }

        // Per-radio details as structured rows
        if (ap.Radios.Count > 0)
        {
            html += "<div class='ap-popup-radios'>";
            foreach (var radio in ap.Radios)
            {
                var radioCode = radio.RadioCode ?? "";
                var bandDisplay = radio.Band?.Replace("'", "\\'") ?? "";
                html += "<div class='ap-popup-radio'>";

                // Band badge (uses standard wifi-band-ng/na/6e CSS classes)
                html += $"<span class='wifi-band-badge wifi-band-{radioCode}'>{bandDisplay}</span>";

                // Channel info
                if (radio.Channel.HasValue)
                {
                    html += $"<span class='ap-radio-detail'>Ch {radio.Channel}";
                    if (radio.ChannelWidth.HasValue)
                        html += $"/{radio.ChannelWidth}";
                    html += "</span>";
                }

                // TX power
                if (radio.TxPowerDbm.HasValue)
                {
                    html += $"<span class='ap-radio-detail'>{radio.TxPowerDbm} dBm";
                    if (radio.Eirp.HasValue)
                        html += $" ({radio.Eirp} EIRP)";
                    html += "</span>";
                }

                html += "</div>";

                // Clients + utilization on second line
                if (radio.Clients.HasValue || radio.Utilization.HasValue)
                {
                    html += "<div class='ap-popup-radio-stats'>";
                    if (radio.Clients.HasValue)
                        html += $"<span>{radio.Clients} client{(radio.Clients != 1 ? "s" : "")}</span>";
                    if (radio.Utilization.HasValue)
                        html += $"<span>{radio.Utilization}% utilization</span>";
                    html += "</div>";
                }
            }
            html += "</div>";
        }

        // Footer: client count, test count, and filter link
        html += "<div class='wifi-tooltip-divider'></div>";
        html += "<div class='map-popup-footer'>";
        html += $"<span class='ap-popup-clients'>{ap.TotalClients} client{(ap.TotalClients != 1 ? "s" : "")}";
        if (testCount > 0)
            html += $" · {testCount} test{(testCount != 1 ? "s" : "")}";
        html += "</span>";
        var isFiltered = !string.IsNullOrEmpty(selectedApMacFilter) &&
            selectedApMacFilter.Equals(ap.Mac, StringComparison.OrdinalIgnoreCase);
        if (isFiltered)
        {
            html += $"<a href='javascript:void(0)' onclick='window._speedTestApFilterAndClose(\"{mapId}\", \"\")' class='map-popup-link'>Clear filter</a>";
        }
        else if (testCount > 0)
        {
            html += $"<a href='javascript:void(0)' onclick='window._speedTestApFilterAndClose(\"{mapId}\", \"{ap.Mac}\")' class='map-popup-link'>Show AP tests</a>";
        }
        html += "</div>";

        html += "</div>";
        return html;
    }

    [JSInvokable]
    public async Task OnApDragEnd(string mac, double lat, double lng)
    {
        if (OnApLocationChanged.HasDelegate)
        {
            await OnApLocationChanged.InvokeAsync((mac, lat, lng));
        }
    }

    [JSInvokable]
    public async Task OnApMarkerClick(string mac)
    {
        await InvokeAsync(async () =>
        {
            var newFilter = string.IsNullOrEmpty(mac) ? null : mac;

            // Skip update if filter hasn't changed (avoids dot flash when reopening same AP)
            if (string.Equals(selectedApMacFilter, newFilter, StringComparison.OrdinalIgnoreCase))
                return;

            if (newFilter != null && mapInitialized)
            {
                if (selectedApMacFilter == null)
                {
                    // No filter → filter: save current view for later restore
                    await JS.InvokeVoidAsync("eval", $@"
                        (function() {{
                            var md = window._speedTestMaps && window._speedTestMaps['{mapId}'];
                            if (md && md.map) md._preFilterBounds = md.map.getBounds();
                        }})();
                    ");
                }
                else
                {
                    // Switching APs: clear saved view (old context is stale)
                    await JS.InvokeVoidAsync("eval", $@"
                        (function() {{
                            var md = window._speedTestMaps && window._speedTestMaps['{mapId}'];
                            if (md) md._preFilterBounds = null;
                        }})();
                    ");
                }
            }

            selectedApMacFilter = newFilter;

            if (mapInitialized)
            {
                // Auto-fit only if it narrows the view (zooms in to show fewer dots)
                // JS fallback will still fit if all filtered dots are off-screen
                await UpdateMarkers(fitBounds: false, fitIfNarrowing: true);
                await UpdateApMarkers(); // Rebuild popups with updated filter text
                await UpdateApGlow();
            }
            StateHasChanged();
        });
    }

    private async Task ClearApFilter()
    {
        selectedApMacFilter = null;
        if (mapInitialized)
        {
            await UpdateMarkers(fitBounds: false);
            await UpdateApMarkers(); // Rebuild popups with updated filter text
            await UpdateApGlow();

            // Restore the view from before the filter was applied
            await JS.InvokeVoidAsync("eval", $@"
                (function() {{
                    var md = window._speedTestMaps && window._speedTestMaps['{mapId}'];
                    if (md && md.map && md._preFilterBounds) {{
                        if (md.setProgrammaticMove) md.setProgrammaticMove(true);
                        md.map.fitBounds(md._preFilterBounds);
                        md._preFilterBounds = null;
                        setTimeout(function() {{
                            if (md.setProgrammaticMove) md.setProgrammaticMove(false);
                        }}, 300);
                    }}
                }})();
            ");
        }
    }

    private async Task UpdateApGlow()
    {
        if (!mapInitialized) return;

        try
        {
            var placedAps = ShowApMarkers
                ? ApMarkers.Where(a => a.Latitude.HasValue && a.Longitude.HasValue).ToArray()
                : Array.Empty<ApMapMarker>();

            var glowData = placedAps.Select(a => new
            {
                lat = a.Latitude!.Value,
                lng = a.Longitude!.Value,
                mac = a.Mac,
                isSelected = a.Mac.Equals(selectedApMacFilter, StringComparison.OrdinalIgnoreCase)
            }).ToArray();

            var glowJson = System.Text.Json.JsonSerializer.Serialize(glowData);

            await JS.InvokeVoidAsync("eval", $@"
                (function() {{
                    const mapData = window._speedTestMaps && window._speedTestMaps['{mapId}'];
                    if (!mapData || !mapData.apGlowGroup) return;

                    mapData._selectedApMac = {(string.IsNullOrEmpty(selectedApMacFilter) ? "null" : $"'{selectedApMacFilter}'")};
                    mapData.apGlowGroup.clearLayers();
                    mapData._apGlowByMac = {{}};
                    const glows = {glowJson};

                    glows.forEach(g => {{
                        const glowIcon = L.divIcon({{
                            html: ""<div class='ap-glow-dot"" + (g.isSelected ? "" ap-glow-selected"" : """") + ""'></div>"",
                            className: 'ap-glow-container',
                            iconSize: [48, 48],
                            iconAnchor: [24, 24]
                        }});
                        const glowMarker = L.marker([g.lat, g.lng], {{
                            icon: glowIcon,
                            interactive: false,
                            pane: 'apGlowPane'
                        }});
                        mapData.apGlowGroup.addLayer(glowMarker);
                        mapData._apGlowByMac[g.mac.toLowerCase()] = glowMarker;
                    }});
                }})();
            ");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"AP glow update error: {ex.Message}");
        }
    }

    private string GetSpeedColor(double mbps)
    {
        if (mbps < 50) return "#ef4444";
        if (mbps < 200) return "#facc15";
        if (mbps < 500) return "#84cc16";
        return "#22c55e";
    }

    /// <summary>
    /// Detects VPN/WAN type based on client IP and known network subnets.
    /// Returns "Tailscale", "VPN", "Teleport", "WAN", or null for LAN.
    /// </summary>
    // TODO: Consider unifying with ClientSpeedTest.DetectVpnType (different signature - this takes IP string, that takes Iperf3Result and checks PathAnalysis first)
    private string? DetectVpnType(string? clientIp)
    {
        if (string.IsNullOrEmpty(clientIp) || !System.Net.IPAddress.TryParse(clientIp, out var ip))
            return null;

        // Check for Tailscale CGNAT range: 100.64.0.0/10 (100.64.0.0 - 100.127.255.255)
        if (clientIp.StartsWith("100."))
        {
            var parts = clientIp.Split('.');
            if (parts.Length >= 2 && int.TryParse(parts[1], out int secondOctet))
            {
                if (secondOctet >= 64 && secondOctet <= 127)
                    return "Tailscale";
            }
        }

        if (_networks != null)
        {
            var matchingNetwork = _networks.FirstOrDefault(n => NetworkUtilities.IsIpInSubnet(clientIp, n.IpSubnet));

            // If in a UniFi VPN network, label as VPN
            if (matchingNetwork?.Purpose == "remote-user-vpn")
                return "VPN";

            // Check for 192.168.x.x not in any known network → Teleport
            if (clientIp.StartsWith("192.168.") && matchingNetwork == null)
                return "Teleport";

            // If not in any known network and not a private IP range, it's WAN (public internet)
            if (matchingNetwork == null && !IsPrivateIp(clientIp))
                return "WAN";
        }

        return null;
    }

    /// <summary>
    /// Checks if an IP address is in a private range (RFC 1918 or CGNAT).
    /// </summary>
    private static bool IsPrivateIp(string ipAddress)
    {
        // 10.0.0.0/8
        if (ipAddress.StartsWith("10."))
            return true;

        // 172.16.0.0/12 (172.16.x.x - 172.31.x.x)
        if (ipAddress.StartsWith("172."))
        {
            var parts = ipAddress.Split('.');
            if (parts.Length >= 2 && int.TryParse(parts[1], out int secondOctet))
            {
                if (secondOctet >= 16 && secondOctet <= 31)
                    return true;
            }
        }

        // 192.168.0.0/16
        if (ipAddress.StartsWith("192.168."))
            return true;

        // 100.64.0.0/10 (CGNAT)
        if (ipAddress.StartsWith("100."))
        {
            var parts = ipAddress.Split('.');
            if (parts.Length >= 2 && int.TryParse(parts[1], out int secondOctet))
            {
                if (secondOctet >= 64 && secondOctet <= 127)
                    return true;
            }
        }

        return false;
    }

    private string BuildPopup(Iperf3Result result, bool isExternal)
    {
        var deviceName = result.DeviceName ?? result.DeviceHost;
        var time = result.TestTime.ToLocalTime().ToString("MMM d, h:mm tt");

        // Determine badge based on VPN detection
        string badge;
        string badgeClass;
        if (isExternal)
        {
            var vpnType = DetectVpnType(result.DeviceHost);
            badge = vpnType ?? "External";
            badgeClass = vpnType != null ? $"map-badge-{vpnType.ToLowerInvariant()}" : "map-badge-external";
        }
        else
        {
            badge = "LAN";
            badgeClass = "map-badge-lan";
        }

        // Get AP name and MAC from path analysis
        var apHop = result.PathAnalysis?.Path?.Hops?
            .FirstOrDefault(h => h.Type == HopType.AccessPoint);
        var apName = apHop?.DeviceName;
        var apMac = apHop?.DeviceMac;

        // Escape for JS string
        deviceName = deviceName?.Replace("'", "\\'").Replace("\"", "&quot;") ?? "Unknown";
        apName = apName?.Replace("'", "\\'").Replace("\"", "&quot;");

        var html = $"<div class='map-popup'>";

        // Header with badge and device name
        html += $"<div class='wifi-tooltip-header'><span class='map-badge {badgeClass}'>{badge}</span> {deviceName}</div>";

        // Speed row
        html += $"<div class='wifi-tooltip-row wifi-tooltip-speed'>";
        html += $"<span class='wifi-speed-rx'>↓ {result.DownloadMbps:F0}</span> · ";
        html += $"<span class='wifi-speed-tx'>↑ {result.UploadMbps:F0}</span> Mbps";
        html += "</div>";

        // AP name if available (clickable to filter + open AP popup)
        if (!string.IsNullOrEmpty(apName))
        {
            if (!string.IsNullOrEmpty(apMac))
                html += $"<div class='wifi-tooltip-link map-tooltip-ap'><strong>AP</strong> <a href='javascript:void(0)' onclick='window._speedTestApFocus(\"{apMac}\")' class='map-popup-link'>{apName}</a></div>";
            else
                html += $"<div class='wifi-tooltip-link map-tooltip-ap'><strong>AP</strong> {apName}</div>";
        }

        // Band and signal if available
        if (result.WifiSignalDbm.HasValue || !string.IsNullOrEmpty(result.WifiRadio))
        {
            html += "<div class='wifi-tooltip-link-signal'>";
            if (!string.IsNullOrEmpty(result.WifiRadio))
            {
                var radio = result.WifiRadio.ToLowerInvariant();
                html += $"<span class='wifi-band-badge wifi-band-{radio}'>{RadioFormatHelper.FormatBand(radio)}</span> ";
            }
            if (result.WifiSignalDbm.HasValue)
            {
                html += $"{result.WifiSignalDbm} dBm";
            }
            html += "</div>";
        }

        // Time and view/client/dashboard links
        html += "<div class='wifi-tooltip-divider'></div>";
        html += $"<div class='map-popup-footer'>";
        html += $"<span class='map-popup-time'>{time}</span>";
        html += "<span class='map-popup-links'>";
        var clientMac = result.ClientMac ?? result.PathAnalysis?.Path?.Hops?
            .FirstOrDefault(h => h.Type == HopType.WirelessClient)?.DeviceMac;
        if (ClientDetailMode && !string.IsNullOrEmpty(clientMac))
        {
            var escapedMac = clientMac.Replace("'", "\\'").Replace("\"", "&quot;");
            html += $"<a href='javascript:void(0)' onclick='window._speedTestClientClick(\"{escapedMac}\")' class='map-popup-link'>Client details \u2192</a>";
        }
        else if (OnResultClick.HasDelegate)
        {
            html += $"<a href='javascript:void(0)' onclick='window._speedTestMapClick({result.Id})' class='map-popup-link'>View \u2192</a>";
        }
        if (ShowDashboardLinks && !string.IsNullOrEmpty(result.DeviceHost))
        {
            var ip = System.Net.WebUtility.HtmlEncode(result.DeviceHost);
            html += $"<a href='/client-dashboard?ip={ip}&amp;tab=speed' class='map-popup-link'>Client Performance \u2192</a>";
        }
        html += "</span>";
        html += "</div>";

        html += "</div>";
        return html;
    }

    [JSInvokable]
    public async Task OnMapResultClick(int resultId)
    {
        if (OnResultClick.HasDelegate)
        {
            await OnResultClick.InvokeAsync(resultId);
        }
    }

    [JSInvokable]
    public async Task OnMapClientClick(string mac)
    {
        if (OnClientClick.HasDelegate)
        {
            await OnClientClick.InvokeAsync(mac);
        }
    }

    [JSInvokable]
    public void OnUserMapInteraction()
    {
        // Only track user interactions after initial setup is complete
        if (initialSetupComplete)
        {
            userHasZoomed = true;
        }
    }

    public void Dispose()
    {
        dotNetRef?.Dispose();
    }
}

<style>
    .speed-test-map-card {
        margin-top: 0;
    }

    .speed-test-map-card .card-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        flex-wrap: wrap;
        gap: 0.75rem;
    }

    .speed-test-map-card .card-title {
        margin: 0;
    }

    .map-filters {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
        align-items: center;
    }

    .map-container {
        position: relative;
    }

    .map-no-results-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(15, 23, 42, 0.85);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        border-radius: 6px;
    }

    .map-no-results-message {
        text-align: center;
        color: var(--text-secondary);
        display: flex;
        flex-direction: column;
        gap: 1rem;
        align-items: center;
    }

    .map-no-results-message span {
        font-size: 1rem;
        color: var(--warning-color);
    }

    .map-footer {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 0.75rem;
        flex-wrap: wrap;
        gap: 0.75rem;
    }

    .map-time-slider {
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    .map-time-slider input[type="range"] {
        width: 140px;
        height: 4px;
        -webkit-appearance: none;
        appearance: none;
        background: linear-gradient(to right, #3b82f6, #60a5fa);
        border-radius: 2px;
        cursor: pointer;
    }

    .map-time-slider input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 14px;
        height: 14px;
        background: #fff;
        border-radius: 50%;
        cursor: pointer;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
    }

    .map-time-slider input[type="range"]::-moz-range-thumb {
        width: 14px;
        height: 14px;
        background: #fff;
        border-radius: 50%;
        cursor: pointer;
        border: none;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
    }

    .map-time-slider .time-label {
        font-size: 0.8rem;
        color: var(--text-muted);
        white-space: nowrap;
        min-width: 60px;
    }

    .map-action-btn {
        margin-left: 0.5rem;
        padding: 0.25rem 0.5rem;
    }

    .map-action-btn svg {
        display: block;
    }

    .speed-test-map {
        height: 520px;
        width: 100%;
        border-radius: 6px;
        z-index: 1;
    }

    .map-legend {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        font-size: 0.8rem;
        color: var(--text-muted);
        margin-left: 0.75rem;
    }

    .legend-item {
        display: flex;
        align-items: center;
        gap: 0.35rem;
    }

    .legend-dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        border: 2px solid #fff;
    }

    @@media (max-width: 768px) {
        .speed-test-map-card .card-body {
            padding: 1rem 0 0.25rem;
        }

        .map-filters {
            justify-content: center;
        }

        .map-footer {
            flex-direction: column;
            align-items: center;
        }

        .map-legend {
            justify-content: center;
            gap: 0.8rem;
            font-size: 0.75rem;
            margin-left: 0;
        }

        .map-time-slider {
            order: 1;
        }

        .map-time-slider input[type="range"] {
            width: 200px;
            height: 8px;
        }

        .map-time-slider input[type="range"]::-webkit-slider-thumb {
            width: 20px;
            height: 20px;
        }

        .map-time-slider input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
        }
    }

    /* Map popup styling */
    .map-popup {
        min-width: 235px;
    }

    .map-badge {
        display: inline-block;
        padding: 0.1rem 0.4rem;
        border-radius: 3px;
        font-size: 0.65rem;
        font-weight: 600;
        text-transform: uppercase;
        margin-right: 0.4rem;
    }

    .map-badge-lan {
        background: rgba(34, 197, 94, 0.2);
        color: #4ade80;
    }

    .map-badge-external {
        background: rgba(100, 116, 139, 0.3);
        color: #94a3b8;
    }

    .map-badge-tailscale {
        background: rgba(59, 130, 246, 0.2);
        color: #60a5fa;
    }

    .map-badge-teleport {
        background: rgba(168, 85, 247, 0.2);
        color: var(--purple-light);
    }

    .map-badge-vpn {
        background: rgba(20, 184, 166, 0.2);
        color: #2dd4bf;
    }

    .map-badge-wan {
        background: rgba(125, 211, 252, 0.2);
        color: #7dd3fc;
    }

    .map-popup-footer {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 0.75rem;
    }

    .map-popup-time {
        color: #64748b;
    }

    .map-popup-links {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 2px;
    }

    .map-popup-link {
        font-weight: 500;
    }

    .map-tooltip-ap {
        padding-left: 0.3rem;
        margin-bottom: 0.35rem;
    }

    /* Dark theme for Leaflet */
    .leaflet-popup-content-wrapper {
        background: #1e293b;
        color: #f1f5f9;
        border-radius: 6px;
        font-family: var(--font-sans);
    }

    .leaflet-popup-tip {
        background: #1e293b;
    }

    .leaflet-popup-content {
        margin: 10px 12px;
    }

    .leaflet-container a.leaflet-popup-close-button {
        color: #94a3b8;
    }

    .leaflet-container a.leaflet-popup-close-button:hover {
        color: #f1f5f9;
    }

    /* Speed-colored cluster icons */
    .speed-cluster {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: bold;
        font-size: 12px;
        border: 2px solid white;
        box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }

    .speed-cluster-icon {
        background: transparent !important;
    }

    /* Dark theme for marker clusters */
    .marker-cluster-small {
        background-color: rgba(59, 130, 246, 0.6);
    }
    .marker-cluster-small div {
        background-color: rgba(59, 130, 246, 0.9);
    }
    .marker-cluster-medium {
        background-color: rgba(234, 179, 8, 0.6);
    }
    .marker-cluster-medium div {
        background-color: rgba(234, 179, 8, 0.9);
    }
    .marker-cluster-large {
        background-color: rgba(239, 68, 68, 0.6);
    }
    .marker-cluster-large div {
        background-color: rgba(239, 68, 68, 0.9);
    }
    .marker-cluster {
        background-clip: padding-box;
        border-radius: 20px;
    }
    .marker-cluster div {
        width: 30px;
        height: 30px;
        margin-left: 5px;
        margin-top: 5px;
        text-align: center;
        border-radius: 15px;
        font: 12px "Helvetica Neue", Arial, Helvetica, sans-serif;
        font-weight: bold;
        color: #fff;
        line-height: 30px;
    }

    /* Animate spider CircleMarker dots on appear */
    .leaflet-overlay-pane svg path.leaflet-interactive {
        animation: fadeIn 0.3s ease-out;
    }

    @@keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
    }

    /* AP marker glow (separate layer behind speed test dots) */
    .ap-glow-container {
        background: transparent !important;
        border: none !important;
    }

    .ap-glow-dot {
        width: 48px;
        height: 48px;
        border-radius: 50%;
        background: radial-gradient(circle, rgba(59, 130, 246, 0.55) 0%, rgba(59, 130, 246, 0.12) 55%, transparent 100%);
        filter: blur(3px);
        transform: scale(var(--ap-scale, 1));
    }

    .ap-glow-dot.ap-glow-selected {
        background: radial-gradient(circle, rgba(59, 130, 246, 0.85) 0%, rgba(59, 130, 246, 0.25) 55%, transparent 100%);
        filter: blur(4px);
    }

    /* AP marker icon (on top of speed test dots) */
    .ap-marker-container {
        background: transparent !important;
        border: none !important;
    }

    .ap-marker-icon {
        width: 32px;
        height: 32px;
        transform: scale(var(--ap-scale, 1));
    }

    /* On-map AP filter chip */
    .map-ap-filter-chip {
        position: absolute;
        bottom: 10px;
        left: 10px;
        z-index: 1000;
        background: var(--primary-color);
        color: white;
        padding: 0.35rem 0.75rem;
        border-radius: 4px;
        font-size: 0.8rem;
        font-weight: 600;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    .map-ap-filter-chip .map-chip-close {
        margin-left: auto;
        margin-top: -2px;
    }

    .map-ap-filter-chip:hover {
        background: var(--primary-hover);
    }

    /* AP marker and popup styles */
    .map-edit-hint {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 1000;
        background: rgba(234, 179, 8, 0.9);
        color: #1e293b;
        padding: 0.35rem 0.75rem;
        border-radius: 4px;
        font-size: 0.8rem;
        font-weight: 600;
        pointer-events: none;
    }

    .map-ap-panel {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 1000;
        background: rgba(15, 23, 42, 0.95);
        border: 1px solid var(--border-color);
        border-radius: 6px;
        padding: 0.75rem;
        max-width: 220px;
        max-height: 400px;
        overflow-y: auto;
    }

    .map-ap-panel-header {
        font-size: 0.8rem;
        color: var(--text-secondary);
        margin-bottom: 0.5rem;
        line-height: 1.4;
    }

    .map-ap-panel-list {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
    }

    .map-ap-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.4rem 0.5rem;
        background: var(--bg-tertiary);
        border: 1px solid transparent;
        border-radius: 4px;
        cursor: pointer;
        color: var(--text-primary);
        font-size: 0.8rem;
        text-align: left;
        transition: all 0.15s ease;
    }

    .map-ap-item:hover {
        background: var(--bg-hover);
        border-color: var(--border-color);
    }

    .map-ap-item.selected {
        background: rgba(59, 130, 246, 0.2);
        border-color: #3b82f6;
    }

    .map-ap-item-icon {
        width: 24px;
        height: 24px;
        flex-shrink: 0;
    }

    .map-ap-item-name {
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }

    .ap-popup {
        min-width: 220px;
    }

    .ap-status-dot {
        display: inline-block;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        margin-right: 0.3rem;
    }

    .ap-status-online {
        background: #22c55e;
    }

    .ap-status-offline {
        background: #ef4444;
    }

    .ap-popup-subtitle {
        font-size: 0.75rem;
        color: #94a3b8;
        margin-bottom: 0.5rem;
    }

    .ap-popup-radios {
        display: flex;
        flex-direction: column;
        gap: 0.15rem;
        margin: 0.35rem 0;
    }

    .ap-popup-radio {
        display: flex;
        align-items: center;
        gap: 0.4rem;
        font-size: 0.75rem;
        line-height: 1.4;
    }

    .ap-radio-detail {
        color: #cbd5e1;
    }

    .ap-popup-radio-stats {
        display: flex;
        gap: 0.75rem;
        font-size: 0.7rem;
        color: #64748b;
        padding-left: 0.2rem;
        margin-bottom: 0.2rem;
    }

    .ap-popup-clients {
        font-size: 0.8rem;
        color: #94a3b8;
    }

    .btn-warning {
        background: rgba(234, 179, 8, 0.3);
        color: #facc15;
        border: 1px solid rgba(234, 179, 8, 0.5);
    }

    .btn-warning:hover {
        background: rgba(234, 179, 8, 0.4);
    }

</style>
