@using NetworkOptimizer.Storage.Models
@using NetworkOptimizer.UniFi
@using NetworkOptimizer.UniFi.Models
@using NetworkOptimizer.Web.Services
@using NetworkOptimizer.Web.Components.Shared
@implements IDisposable

<div class="speed-results">
    @if (DownloadMbps > 0)
    {
        <div class="speed-result download">
            <div class="speed-icon">
                <svg viewBox="0 0 24 24" width="32" height="32">
                    <path d="M12 4v12m0 0l-4-4m4 4l4-4M5 18h14" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </div>
            <div class="speed-details">
                <div class="speed-label">From Device <span class="tooltip-icon tooltip-icon-sm" data-tooltip="Data transferred from the tested device to this server">?</span></div>
                <div class="speed-value">@DownloadMbps.ToString("F1") <span class="speed-unit">Mbps</span></div>
                <div class="speed-meta">@FormatBytes(DownloadBytes) transferred</div>
            </div>
        </div>
    }
    @if (UploadMbps > 0)
    {
        <div class="speed-result upload">
            <div class="speed-icon">
                <svg viewBox="0 0 24 24" width="32" height="32">
                    <path d="M12 20V8m0 0l4 4m-4-4l-4 4M5 6h14" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </div>
            <div class="speed-details">
                <div class="speed-label">To Device <span class="tooltip-icon tooltip-icon-sm" data-tooltip="Data transferred to the tested device from this server">?</span></div>
                <div class="speed-value">@UploadMbps.ToString("F1") <span class="speed-unit">Mbps</span></div>
                <div class="speed-meta">@FormatBytes(UploadBytes) transferred</div>
            </div>
        </div>
    }
</div>
@if (DownloadRetransmits > 0 || UploadRetransmits > 0)
{
    <div class="retransmits-info">
        <small>Retransmits: @DownloadRetransmits from / @UploadRetransmits to</small>
    </div>
}
<div class="test-details">
    @if (IsInTableRow)
    {
        <span class="hide-mobile">Host: @DeviceHost</span>
    }
    else
    {
        <span>Device: @DeviceName (@DeviceHost)</span>
    }
    <span class="hide-mobile">Duration: @DurationSeconds seconds</span>
    <span class="show-mobile">Duration: @(DurationSeconds)s</span>
    <span>Streams: @ParallelStreams parallel</span>
    @if (PingMs.HasValue)
    {
        <span>Ping: @(PingMs.Value % 1 == 0 && PingMs.Value >= 10 ? PingMs.Value.ToString("F0") : PingMs.Value.ToString("F1")) ms</span>
    }
    <span class="hide-mobile">Time: @TestTime.ToLocalTime().ToString("g")</span>
    <span class="show-mobile">@TimeFormatHelper.FormatRelativeTimeShort(TestTime)</span>
    @if (OnDelete.HasDelegate && Result != null)
    {
        <span class="delete-action">
            <button class="btn-link-danger" @onclick="HandleDelete" disabled="@_deleting" data-tooltip="Delete this result">
                @if (_deleting)
                {
                    <span class="spinner-sm"></span>
                }
                else
                {
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
                    </svg>
                }
            </button>
        </span>
    }
</div>

@if (PathAnalysis != null)
{
    <div class="path-analysis">
        @if (PathAnalysis.Path.IsValid)
        {
            <div class="path-summary">
                <div class="path-max-speed">
                    <span class="speed-value">@FormatPathMaxSpeed()</span>
                    <span class="speed-label">max</span>
                </div>
                <div class="efficiency-grades">
                    @if (DownloadMbps > 0)
                    {
                        <div class="grade-item">
                            <span class="grade-badge @GetGradeClass(GetDisplayGrade(isFromDevice: true))" data-tooltip="@GetEfficiencyTooltip(isFromDevice: true)">
                                â†“ @GetDisplayEfficiency(isFromDevice: true).ToString("F0")%
                            </span>
                        </div>
                    }
                    @if (UploadMbps > 0)
                    {
                        <div class="grade-item">
                            <span class="grade-badge @GetGradeClass(GetDisplayGrade(isFromDevice: false))" data-tooltip="@GetEfficiencyTooltip(isFromDevice: false)">
                                â†‘ @GetDisplayEfficiency(isFromDevice: false).ToString("F0")%
                            </span>
                        </div>
                    }
                </div>
                @if (Result != null && OnNotesChanged.HasDelegate)
                {
                    <div class="result-notes" @onclick:stopPropagation="true">
                        <textarea class="notes-input"
                                  placeholder="Add notes..."
                                  @bind="_notesInput"
                                  @bind:event="oninput"
                                  @onkeyup="OnNotesKeyUp"
                                  rows="2"></textarea>
                        @if (_notesSaving)
                        {
                            <span class="notes-status saving">Saving...</span>
                        }
                        else if (_notesSaved)
                        {
                            <span class="notes-status saved">Saved</span>
                        }
                    </div>
                }
            </div>

            @if (PathAnalysis.Path.Hops.Count > 0)
            {
                var hops = PathAnalysis.Path.Hops;
                var rows = GetHopRows(hops);
                var needsSwitchback = rows.Count > 1;

                <div class="path-visualization @(needsSwitchback ? "path-switchback" : "")">
                    @for (var rowIndex = 0; rowIndex < rows.Count; rowIndex++)
                    {
                        var row = rows[rowIndex];
                        var isReversed = rowIndex % 2 == 1;
                        var isLastRow = rowIndex == rows.Count - 1;

                        <div class="path-row @(isReversed ? "reversed" : "")">
                            @{
                                // For reversed rows, iterate backwards through the row
                                var indices = isReversed
                                    ? Enumerable.Range(0, row.Count).Reverse().ToList()
                                    : Enumerable.Range(0, row.Count).ToList();
                            }

                            @* Turn connector at START of reversed rows (exit on left side) *@
                            @if (isReversed && !isLastRow)
                            {
                                // Get the last hop in the row (index 0) which connects to next row
                                var lastHopData = row[0];
                                var lastHop = lastHopData.Hop;
                                var lastGlobalIdx = lastHopData.GlobalIndex;
                                if (lastGlobalIdx < hops.Count - 1)
                                {
                                    var nextHopGlobal = hops[lastGlobalIdx + 1];
                                    var linkSpeed = GetLinkSpeed(lastHop, nextHopGlobal);
                                    var isBottleneckLink = PathAnalysis.Path.HasRealBottleneck && (lastHop.IsBottleneck || nextHopGlobal.IsBottleneck);
                                    var isWirelessLink = lastHop.IsWirelessEgress || nextHopGlobal.IsWirelessIngress;
                                    var turnTooltip = isWirelessLink
                                        ? GetWifiTooltip(lastHop, nextHopGlobal, isBottleneckLink)
                                        : (isBottleneckLink ? "Bottleneck: slowest link in path" : null);

                                    <div class="path-connector path-turn turn-left @(isBottleneckLink ? "bottleneck" : "") @(isWirelessLink ? "wireless" : "")" data-tooltip="@turnTooltip">
                                        @if (isWirelessLink)
                                        {
                                            <span class="wireless-icon">ðŸ“¶</span>
                                        }
                                        <span class="connector-line"></span>
                                        @if (linkSpeed > 0)
                                        {
                                            <span class="connector-speed">@FormatSpeed(linkSpeed)</span>
                                        }
                                        <span class="turn-corner"></span>
                                    </div>
                                }
                            }

                            @foreach (var localIdx in indices)
                            {
                                var hopData = row[localIdx];
                                var hop = hopData.Hop;
                                var globalIdx = hopData.GlobalIndex;
                                var isLastHopInRow = isReversed ? localIdx == 0 : localIdx == row.Count - 1;
                                var isLastHopInPath = globalIdx == hops.Count - 1;
                                var deviceTooltip = GetDeviceTooltip(hop);

                                @* Connector BEFORE hop for reversed rows (between hops, not at the start) *@
                                @if (isReversed && localIdx != row.Count - 1 && globalIdx < hops.Count - 1)
                                {
                                    var nextHopGlobal = hops[globalIdx + 1];
                                    var linkSpeed = GetLinkSpeed(hop, nextHopGlobal);
                                    var isBottleneckLink = PathAnalysis.Path.HasRealBottleneck && (hop.IsBottleneck || nextHopGlobal.IsBottleneck);
                                    var isWirelessLink = hop.IsWirelessEgress || nextHopGlobal.IsWirelessIngress;
                                    var connectorTooltip1 = isWirelessLink
                                        ? GetWifiTooltip(hop, nextHopGlobal, isBottleneckLink)
                                        : (isBottleneckLink ? "Bottleneck: slowest link in path" : null);

                                    <div class="path-connector arrow-left @(isBottleneckLink ? "bottleneck" : "") @(isWirelessLink ? "wireless" : "")" data-tooltip="@connectorTooltip1">
                                        @if (isWirelessLink)
                                        {
                                            <span class="wireless-icon">ðŸ“¶</span>
                                        }
                                        <span class="connector-line"></span>
                                        @if (linkSpeed > 0)
                                        {
                                            <span class="connector-speed">@FormatSpeed(linkSpeed)</span>
                                        }
                                    </div>
                                }

                                @* Render the hop *@
                                @if (!string.IsNullOrEmpty(deviceTooltip))
                                {
                                    <div class="path-hop @(hop.IsBottleneck ? "bottleneck" : "") @GetHopTypeClass(hop.Type)" data-tooltip="@deviceTooltip">
                                        <span class="hop-icon">@GetHopIconMarkup(hop)</span>
                                        <span class="hop-name">@hop.DeviceName</span>
                                    </div>
                                }
                                else
                                {
                                    <div class="path-hop @(hop.IsBottleneck ? "bottleneck" : "") @GetHopTypeClass(hop.Type)">
                                        <span class="hop-icon">@GetHopIconMarkup(hop)</span>
                                        <span class="hop-name">@hop.DeviceName</span>
                                    </div>
                                }

                                @* Connector AFTER hop for non-reversed rows *@
                                @if (!isReversed && globalIdx < hops.Count - 1)
                                {
                                    var nextHopGlobal = hops[globalIdx + 1];
                                    var linkSpeed = GetLinkSpeed(hop, nextHopGlobal);
                                    var isBottleneckLink = PathAnalysis.Path.HasRealBottleneck && (hop.IsBottleneck || nextHopGlobal.IsBottleneck);
                                    var isWirelessLink = hop.IsWirelessEgress || nextHopGlobal.IsWirelessIngress;
                                    var needsTurn = isLastHopInRow && !isLastRow;
                                    var connectorTooltip2 = isWirelessLink
                                        ? GetWifiTooltip(hop, nextHopGlobal, isBottleneckLink)
                                        : (isBottleneckLink ? "Bottleneck: slowest link in path" : null);

                                    <div class="path-connector @(needsTurn ? "path-turn" : "") @(isBottleneckLink ? "bottleneck" : "") @(isWirelessLink ? "wireless" : "")" data-tooltip="@connectorTooltip2">
                                        @if (isWirelessLink)
                                        {
                                            <span class="wireless-icon">ðŸ“¶</span>
                                        }
                                        <span class="connector-line"></span>
                                        @if (linkSpeed > 0)
                                        {
                                            <span class="connector-speed">@FormatSpeed(linkSpeed)</span>
                                        }
                                        @if (needsTurn)
                                        {
                                            <span class="turn-corner"></span>
                                        }
                                    </div>
                                }

                            }
                        </div>
                    }
                </div>
            }

            @if (PathAnalysis.Path.HasRealBottleneck)
            {
                <div class="bottleneck-warning" data-tooltip="This is the slowest link in the path, limiting overall throughput">
                    @FormatBottleneckDescription()
                </div>
            }

            @if (PathAnalysis.Path.RequiresRouting && !PathAnalysis.Path.IsExternalPath)
            {
                <div class="routing-badge">
                    ðŸ”€ Inter-VLAN via @(PathAnalysis.Path.GatewayDevice ?? "gateway")
                </div>
            }
        }
        else
        {
            <div class="path-error">
                @(PathAnalysis.Path.ErrorMessage ?? "Path analysis unavailable")
            </div>
        }

        @{
            // Filter out misleading messages when one direction has 0 Mbps (wasn't tested)
            var hasZeroDirection = DownloadMbps == 0 || UploadMbps == 0;
            var filteredInsights = hasZeroDirection
                ? PathAnalysis.Insights.Where(i => !i.Contains("Performance below expected", StringComparison.OrdinalIgnoreCase))
                : PathAnalysis.Insights;
            var filteredRecs = hasZeroDirection
                ? PathAnalysis.Recommendations.Where(r => !r.Contains("asymmetry", StringComparison.OrdinalIgnoreCase))
                : PathAnalysis.Recommendations;
        }
        @if (filteredInsights.Any() || filteredRecs.Any())
        {
            <div class="path-notes">
                @foreach (var insight in filteredInsights)
                {
                    <div class="note insight">@insight</div>
                }
                @foreach (var rec in filteredRecs)
                {
                    <div class="note recommendation">@rec</div>
                }
            </div>
        }
    </div>
}

@code {
    [Parameter] public double DownloadMbps { get; set; }
    [Parameter] public double UploadMbps { get; set; }
    [Parameter] public long DownloadBytes { get; set; }
    [Parameter] public long UploadBytes { get; set; }
    [Parameter] public int DownloadRetransmits { get; set; }
    [Parameter] public int UploadRetransmits { get; set; }
    [Parameter] public string DeviceName { get; set; } = "";
    [Parameter] public string DeviceHost { get; set; } = "";
    [Parameter] public int DurationSeconds { get; set; }
    [Parameter] public int ParallelStreams { get; set; }
    [Parameter] public bool IsInTableRow { get; set; }
    [Parameter] public DateTime TestTime { get; set; }
    [Parameter] public double? PingMs { get; set; }

    /// <summary>
    /// Path analysis result (set automatically when using Result parameter)
    /// </summary>
    [Parameter] public PathAnalysisResult? PathAnalysis { get; set; }

    /// <summary>
    /// Convenience parameter to set all values from an Iperf3Result
    /// </summary>
    [Parameter] public Iperf3Result? Result { get; set; }

    /// <summary>
    /// Convenience parameter to set all values from a GatewaySpeedTestResult
    /// </summary>
    [Parameter] public GatewaySpeedTestResult? GatewayResult { get; set; }

    /// <summary>
    /// Callback invoked when the user confirms deletion.
    /// If not provided, the delete button is hidden.
    /// </summary>
    [Parameter] public EventCallback<int> OnDelete { get; set; }

    /// <summary>
    /// Callback invoked when notes are changed (after debounce).
    /// Parameters: (resultId, notes)
    /// </summary>
    [Parameter] public EventCallback<(int Id, string? Notes)> OnNotesChanged { get; set; }

    // Track previous Result ID to detect when Result changes
    private int? _previousResultId;

    // Delete state
    private bool _deleting;
    private bool _disposed;

    // Notes state
    private string _notesInput = "";
    private bool _notesSaving;
    private bool _notesSaved;
    private System.Timers.Timer? _notesDebounceTimer;
    private System.Timers.Timer? _notesSavedTimer;

    protected override void OnParametersSet()
    {
        if (Result != null)
        {
            // Detect if Result changed (different test)
            bool resultChanged = _previousResultId != Result.Id;
            _previousResultId = Result.Id;

            DownloadMbps = Result.DownloadMbps;
            UploadMbps = Result.UploadMbps;
            DownloadBytes = Result.DownloadBytes;
            UploadBytes = Result.UploadBytes;
            DownloadRetransmits = Result.DownloadRetransmits;
            UploadRetransmits = Result.UploadRetransmits;
            DeviceName = Result.DeviceName ?? "";
            DeviceHost = Result.DeviceHost;
            DurationSeconds = Result.DurationSeconds;
            ParallelStreams = Result.ParallelStreams;
            TestTime = Result.TestTime;
            PingMs = Result.PingMs;

            // Sync PathAnalysis from Result when Result changes
            // This ensures we don't show stale analysis from a previous test
            if (resultChanged)
            {
                PathAnalysis = Result.PathAnalysis;
                // Sync notes from Result
                _notesInput = Result.Notes ?? "";
                _notesSaved = false;
            }
            else
            {
                // Only use Result.PathAnalysis if no separate PathAnalysis was passed
                PathAnalysis ??= Result.PathAnalysis;
            }
        }
        else if (GatewayResult != null)
        {
            DownloadMbps = GatewayResult.DownloadMbps;
            UploadMbps = GatewayResult.UploadMbps;
            DownloadBytes = GatewayResult.DownloadBytes;
            UploadBytes = GatewayResult.UploadBytes;
            DownloadRetransmits = GatewayResult.DownloadRetransmits;
            UploadRetransmits = GatewayResult.UploadRetransmits;
            DeviceName = "Gateway";
            DeviceHost = GatewayResult.GatewayHost ?? "";
            DurationSeconds = GatewayResult.DurationSeconds;
            ParallelStreams = GatewayResult.ParallelStreams;
            TestTime = GatewayResult.TestTime;
        }
    }

    private string FormatBytes(long bytes)
    {
        if (bytes < 1024)
            return $"{bytes} B";
        if (bytes < 1024 * 1024)
            return $"{bytes / 1024.0:F1} KB";
        if (bytes < 1024 * 1024 * 1024)
            return $"{bytes / (1024.0 * 1024.0):F1} MB";
        return $"{bytes / (1024.0 * 1024.0 * 1024.0):F2} GB";
    }

    // Switchback layout helpers
    private record HopData(NetworkHop Hop, int GlobalIndex);
    private const int MaxHopsPerRow = 6;
    private const int MaxCharsPerRow = 142; // Approximate character budget per row

    private List<List<HopData>> GetHopRows(IList<NetworkHop> hops)
    {
        var rows = new List<List<HopData>>();
        var currentRow = new List<HopData>();
        var currentRowChars = 0;

        for (int i = 0; i < hops.Count; i++)
        {
            var hopChars = (hops[i].DeviceName?.Length ?? 0) + 9; // +9 for padding, icon, connector (~80px)

            // Start new row if adding this hop would exceed limits
            if (currentRow.Count > 0 &&
                (currentRow.Count >= MaxHopsPerRow || currentRowChars + hopChars > MaxCharsPerRow))
            {
                rows.Add(currentRow);
                currentRow = new List<HopData>();
                currentRowChars = 0;
            }

            currentRow.Add(new HopData(hops[i], i));
            currentRowChars += hopChars;
        }

        if (currentRow.Count > 0)
            rows.Add(currentRow);

        return rows;
    }

    private string FormatSpeed(int mbps)
    {
        if (mbps >= 1000)
        {
            var gbps = mbps / 1000.0;
            return gbps % 1 == 0 ? $"{(int)gbps} Gbps" : $"{gbps:F1} Gbps";
        }
        return $"{mbps} Mbps";
    }

    private string FormatSpeedCompact(double mbps)
    {
        if (mbps >= 1000)
        {
            var gbps = mbps / 1000.0;
            return gbps % 1 == 0 ? $"{(int)gbps} Gbps" : $"{gbps:F1} Gbps";
        }
        return $"{mbps:F0} Mbps";
    }

    private string GetGradeClass(PerformanceGrade grade) => grade switch
    {
        PerformanceGrade.Excellent => "grade-excellent",
        PerformanceGrade.Good => "grade-good",
        PerformanceGrade.Fair => "grade-fair",
        PerformanceGrade.Poor => "grade-poor",
        PerformanceGrade.Critical => "grade-critical",
        _ => ""
    };

    private string GetHopTypeClass(HopType type) => type switch
    {
        HopType.Client => "hop-client",
        HopType.WirelessClient => "hop-client",
        HopType.Switch => "hop-switch",
        HopType.AccessPoint => "hop-ap",
        HopType.Gateway => "hop-gateway",
        HopType.Server => "hop-server",
        HopType.Teleport => "hop-teleport",
        HopType.Tailscale => "hop-tailscale",
        HopType.Wan => "hop-wan",
        HopType.Vpn => "hop-vpn",
        _ => ""
    };

    /// <summary>
    /// Get device tooltip showing type, model, and firmware for UniFi devices
    /// </summary>
    private string? GetDeviceTooltip(NetworkHop hop)
    {
        // Only show tooltip for UniFi devices (those with a model)
        if (string.IsNullOrEmpty(hop.DeviceModel))
            return null;

        var deviceType = GetDeviceTypeName(hop.Type);
        var lines = new List<string>();

        lines.Add($"<div class='device-tooltip-row'><span class='device-tooltip-label'>Type:</span> {deviceType}</div>");
        lines.Add($"<div class='device-tooltip-row'><span class='device-tooltip-label'>Model:</span> {hop.DeviceModel}</div>");

        if (!string.IsNullOrEmpty(hop.DeviceFirmware))
        {
            lines.Add($"<div class='device-tooltip-row'><span class='device-tooltip-label'>Firmware:</span> {hop.DeviceFirmware}</div>");
        }

        return string.Join("", lines);
    }

    private string GetDeviceTypeName(HopType type) => type switch
    {
        HopType.Switch => "Switch",
        HopType.AccessPoint => "Access Point",
        HopType.Gateway => "Gateway",
        HopType.Server => "Server",
        HopType.Client => "Client",
        HopType.WirelessClient => "Wireless Client",
        HopType.Teleport => "Teleport VPN",
        HopType.Tailscale => "Tailscale VPN",
        HopType.Wan => "WAN",
        HopType.Vpn => "VPN",
        _ => "Device"
    };

    private string GetHopIcon(HopType type) => type switch
    {
        HopType.Client => "ðŸ–¥ï¸",
        HopType.WirelessClient => "ðŸ’»",
        HopType.Switch => "ðŸ”€",
        HopType.AccessPoint => "ðŸ“¶",
        HopType.Gateway => "ðŸŒ",
        HopType.Server => "ðŸ–¥ï¸",
        HopType.Teleport => "ðŸ”’",
        HopType.Tailscale => "ðŸ”’",
        HopType.Wan => "ðŸŒ",
        HopType.Vpn => "ðŸ”’",
        _ => "â€¢"
    };

    /// <summary>
    /// Calculate link speed between two adjacent hops.
    /// For wireless/WAN hops, uses IngressSpeedMbps (TX to device or download).
    /// For wired hops, uses EgressSpeedMbps (port toward next hop) with fallback to nextHop's Ingress.
    /// </summary>
    private int GetLinkSpeed(NetworkHop hop, NetworkHop nextHop)
    {
        var isWanType = hop.Type == HopType.Tailscale || hop.Type == HopType.Teleport || hop.Type == HopType.Wan;
        return (hop.IsWirelessIngress || isWanType)
            ? hop.IngressSpeedMbps
            : (hop.EgressSpeedMbps > 0 ? hop.EgressSpeedMbps : nextHop.IngressSpeedMbps);
    }

    /// <summary>
    /// Get Wi-Fi signal tooltip content from the hop or Result
    /// </summary>
    /// <param name="hop">The current hop</param>
    /// <param name="nextHop">The next hop in the path</param>
    /// <param name="isBottleneck">Whether this link is the bottleneck</param>
    private string GetWifiTooltip(NetworkHop hop, NetworkHop nextHop, bool isBottleneck = false)
    {
        // Determine if this is the client's wireless connection (first hop is WirelessClient)
        // or a mesh/bridge wireless link
        var isClientWireless = hop.Type == HopType.WirelessClient || nextHop.Type == HopType.WirelessClient;

        // Get band from hop (mesh) or result (client)
        string? band = null;
        if (hop.IsWirelessEgress && !string.IsNullOrEmpty(hop.WirelessEgressBand))
            band = hop.WirelessEgressBand;
        else if (nextHop.IsWirelessIngress && !string.IsNullOrEmpty(nextHop.WirelessIngressBand))
            band = nextHop.WirelessIngressBand;

        // For client wireless, also show signal/noise from Result
        if (isClientWireless && Result != null)
        {
            // Check for MLO (Multi-Link Operation) - use unified styling
            if (Result.WifiIsMlo && !string.IsNullOrEmpty(Result.WifiMloLinksJson))
            {
                var mloTooltip = BuildMloTooltip();
                return isBottleneck ? mloTooltip + "<div class='wifi-tooltip-bottleneck'>Bottleneck: slowest link in path</div>" : mloTooltip;
            }

            // Single-link wireless - use same styled format as MLO
            var lines = new List<string>();
            var clientBand = !string.IsNullOrEmpty(Result.WifiRadio) ? Result.WifiRadio : band;

            // Header with protocol
            if (!string.IsNullOrEmpty(Result.WifiRadioProto))
                lines.Add($"<div class='wifi-tooltip-header'>Wi-Fi {FormatRadioProto(Result.WifiRadioProto, clientBand)}</div>");

            // RX/TX speeds (RX first = "from device", TX = "to device")
            if (Result.WifiTxRateKbps.HasValue || Result.WifiRxRateKbps.HasValue)
            {
                var speedParts = new List<string>();
                if (Result.WifiRxRateKbps.HasValue && Result.WifiRxRateKbps.Value > 0)
                    speedParts.Add($"<span class='wifi-speed-rx'>RX {Math.Round(Result.WifiRxRateKbps.Value / 1000.0)} Mbps</span>");
                if (Result.WifiTxRateKbps.HasValue && Result.WifiTxRateKbps.Value > 0)
                    speedParts.Add($"<span class='wifi-speed-tx'>TX {Math.Round(Result.WifiTxRateKbps.Value / 1000.0)} Mbps</span>");
                if (speedParts.Count > 0)
                    lines.Add($"<div class='wifi-tooltip-row wifi-tooltip-speed'>{string.Join(" Â· ", speedParts)}</div>");
            }

            // Link info with band badge
            if (!string.IsNullOrEmpty(clientBand) || Result.WifiChannel.HasValue)
            {
                var linkParts = new List<string>();
                if (!string.IsNullOrEmpty(clientBand))
                    linkParts.Add($"<span class='wifi-band-badge wifi-band-{clientBand}'>{FormatRadioBand(clientBand)}</span>");
                if (Result.WifiChannel.HasValue)
                    linkParts.Add($"Ch {Result.WifiChannel.Value}");
                lines.Add($"<div class='wifi-tooltip-link'>{string.Join(" ", linkParts)}</div>");
            }

            // Signal line
            if (Result.WifiSignalDbm.HasValue)
            {
                var sigParts = new List<string> { $"{Result.WifiSignalDbm.Value} dBm" };
                if (Result.WifiNoiseDbm.HasValue)
                    sigParts.Add($"SNR {Result.WifiSignalDbm.Value - Result.WifiNoiseDbm.Value} dB");
                lines.Add($"<div class='wifi-tooltip-link-signal'>{string.Join(" Â· ", sigParts)}</div>");
            }

            var clientTooltip = lines.Count > 0 ? string.Join("", lines) : "Wireless connection";
            return isBottleneck ? clientTooltip + "<div class='wifi-tooltip-bottleneck'>Bottleneck: slowest link in path</div>" : clientTooltip;
        }

        // For mesh/bridge wireless - use same styled format
        var meshHop = hop.IsWirelessEgress ? hop : nextHop;
        var lines2 = new List<string>();

        lines2.Add("<div class='wifi-tooltip-header'>Wireless Mesh</div>");

        // RX/TX speeds (RX first = "from device", TX = "to device")
        if (meshHop.WirelessTxRateMbps.HasValue || meshHop.WirelessRxRateMbps.HasValue)
        {
            var speedParts = new List<string>();
            if (meshHop.WirelessRxRateMbps.HasValue)
                speedParts.Add($"<span class='wifi-speed-rx'>RX {meshHop.WirelessRxRateMbps.Value} Mbps</span>");
            if (meshHop.WirelessTxRateMbps.HasValue)
                speedParts.Add($"<span class='wifi-speed-tx'>TX {meshHop.WirelessTxRateMbps.Value} Mbps</span>");
            lines2.Add($"<div class='wifi-tooltip-row wifi-tooltip-speed'>{string.Join(" Â· ", speedParts)}</div>");
        }

        // Link info with band badge
        if (!string.IsNullOrEmpty(band) || meshHop.WirelessChannel.HasValue)
        {
            var linkParts = new List<string>();
            if (!string.IsNullOrEmpty(band))
                linkParts.Add($"<span class='wifi-band-badge wifi-band-{band}'>{FormatRadioBand(band)}</span>");
            if (meshHop.WirelessChannel.HasValue)
                linkParts.Add($"Ch {meshHop.WirelessChannel.Value}");
            lines2.Add($"<div class='wifi-tooltip-link'>{string.Join(" ", linkParts)}</div>");
        }

        // Signal line
        if (meshHop.WirelessSignalDbm.HasValue)
        {
            var sigParts = new List<string> { $"{meshHop.WirelessSignalDbm.Value} dBm" };
            if (meshHop.WirelessNoiseDbm.HasValue)
                sigParts.Add($"SNR {meshHop.WirelessSignalDbm.Value - meshHop.WirelessNoiseDbm.Value} dB");
            lines2.Add($"<div class='wifi-tooltip-link-signal'>{string.Join(" Â· ", sigParts)}</div>");
        }

        var meshTooltip = lines2.Count > 1 ? string.Join("", lines2) : "Wireless mesh";
        return isBottleneck ? meshTooltip + "<div class='wifi-tooltip-bottleneck'>Bottleneck: slowest link in path</div>" : meshTooltip;
    }

    /// <summary>
    /// Build tooltip content for MLO (Multi-Link Operation) Wi-Fi 7 connections
    /// </summary>
    private string BuildMloTooltip()
    {
        if (Result == null || string.IsNullOrEmpty(Result.WifiMloLinksJson))
            return "Wi-Fi 7 MLO";

        try
        {
            var links = System.Text.Json.JsonSerializer.Deserialize<List<MloLinkData>>(Result.WifiMloLinksJson);
            if (links == null || links.Count == 0)
                return "Wi-Fi 7 MLO";

            var lines = new List<string>();

            // Header with Wi-Fi 7 MLO badge
            lines.Add("<div class='wifi-tooltip-header'>Wi-Fi 7 (be) Â· MLO</div>");

            // Sum link speeds
            var totalTxMbps = links.Where(l => l.txRate.HasValue).Sum(l => l.txRate!.Value / 1000.0);
            var totalRxMbps = links.Where(l => l.rxRate.HasValue).Sum(l => l.rxRate!.Value / 1000.0);

            if (totalTxMbps > 0 || totalRxMbps > 0)
            {
                var speedParts = new List<string>();
                if (totalRxMbps > 0) speedParts.Add($"<span class='wifi-speed-rx'>RX {totalRxMbps:F0} Mbps</span>");
                if (totalTxMbps > 0) speedParts.Add($"<span class='wifi-speed-tx'>TX {totalTxMbps:F0} Mbps</span>");
                lines.Add($"<div class='wifi-tooltip-row wifi-tooltip-speed'>{string.Join(" Â· ", speedParts)}</div>");
            }

            // Divider
            lines.Add("<div class='wifi-tooltip-divider'></div>");

            // Each link
            foreach (var link in links.OrderByDescending(l => l.channelWidth ?? 0))
            {
                var linkParts = new List<string>();

                // Band badge
                if (!string.IsNullOrEmpty(link.radio))
                    linkParts.Add($"<span class='wifi-band-badge wifi-band-{link.radio}'>{FormatRadioBand(link.radio)}</span>");

                // Channel/width
                if (link.channel.HasValue)
                {
                    var chInfo = $"Ch {link.channel.Value}";
                    if (link.channelWidth.HasValue)
                        chInfo += $" ({link.channelWidth.Value} MHz)";
                    linkParts.Add(chInfo);
                }

                lines.Add($"<div class='wifi-tooltip-link'>{string.Join(" ", linkParts)}</div>");

                // Per-link RX/TX rates (RX first = "from device", TX = "to device")
                if (link.txRate.HasValue || link.rxRate.HasValue)
                {
                    var linkSpeedParts = new List<string>();
                    if (link.rxRate.HasValue)
                        linkSpeedParts.Add($"<span class='wifi-speed-rx'>RX {Math.Round(link.rxRate.Value / 1000.0)} Mbps</span>");
                    if (link.txRate.HasValue)
                        linkSpeedParts.Add($"<span class='wifi-speed-tx'>TX {Math.Round(link.txRate.Value / 1000.0)} Mbps</span>");
                    lines.Add($"<div class='wifi-tooltip-link-speed'>{string.Join(" Â· ", linkSpeedParts)}</div>");
                }

                // Signal for this link
                if (link.signal.HasValue)
                {
                    var sigParts = new List<string> { $"{link.signal.Value} dBm" };
                    if (link.signal.HasValue && link.noise.HasValue)
                        sigParts.Add($"SNR {link.signal.Value - link.noise.Value} dB");
                    lines.Add($"<div class='wifi-tooltip-link-signal'>{string.Join(" Â· ", sigParts)}</div>");
                }
            }

            return string.Join("", lines);
        }
        catch
        {
            return "Wi-Fi 7 MLO";
        }
    }

    // DTO for deserializing MLO link JSON
    private record MloLinkData(
        string? radio,
        int? channel,
        int? channelWidth,
        int? signal,
        int? noise,
        long? txRate,
        long? rxRate
    );

    private string FormatRadioBand(string? radio) => RadioFormatHelper.FormatBand(radio);

    private string FormatRadioProto(string? proto, string? radio = null) =>
        RadioFormatHelper.FormatProtocolSuffix(proto, radio);

    /// <summary>
    /// Render a device icon for the path hop, falling back to emoji if no icon available
    /// </summary>
    private RenderFragment GetHopIconMarkup(NetworkHop hop) => builder =>
    {
        // VPN hops get custom SVG icons
        if (hop.Type == HopType.Teleport)
        {
            builder.OpenElement(0, "svg");
            builder.AddAttribute(1, "viewBox", "0 0 20 20");
            builder.AddAttribute(2, "width", "24");
            builder.AddAttribute(3, "height", "24");
            builder.AddAttribute(4, "class", "vpn-icon teleport-icon");
            builder.AddMarkupContent(5, @"<path fill-rule=""evenodd"" clip-rule=""evenodd"" d=""M5.111 7.255c-.125-1.072-.318-1.952-.544-2.55-.115-.3-.227-.502-.322-.618a.555.555 0 0 0-.066-.07.897.897 0 0 0-.183.243c-.156.27-.312.693-.45 1.26-.275 1.127-.45 2.708-.45 4.474 0 1.765.175 3.347.45 4.473.138.567.294.99.45 1.26.086.15.15.216.183.244a.558.558 0 0 0 .068-.072c.096-.12.21-.324.324-.63.228-.606.422-1.497.545-2.582a.5.5 0 1 1 .994.114c-.129 1.126-.335 2.107-.603 2.82-.133.354-.291.67-.483.908-.188.231-.47.459-.845.459-.51 0-.848-.41-1.05-.761-.223-.388-.407-.915-.555-1.523-.299-1.224-.478-2.89-.478-4.71 0-1.821.18-3.486.478-4.71.148-.609.332-1.136.555-1.523C3.331 3.41 3.67 3 4.18 3c.373 0 .653.224.84.454.192.235.35.548.483.898.267.704.473 1.673.603 2.788a.5.5 0 0 1-.994.115Zm-.96 8.736-.003.001h.003ZM15.543 4.706c-.227.597-.42 1.477-.545 2.55a.5.5 0 0 1-.993-.116c.13-1.115.336-2.084.603-2.788.132-.35.29-.663.482-.898.187-.23.467-.454.84-.454.511 0 .848.41 1.05.76.223.388.407.915.555 1.524.299 1.224.478 2.889.478 4.71 0 1.82-.18 3.486-.478 4.71-.148.608-.332 1.135-.555 1.523-.202.35-.539.76-1.05.76-.375 0-.656-.227-.844-.458-.193-.238-.351-.554-.484-.908-.268-.713-.474-1.694-.603-2.82a.5.5 0 1 1 .994-.114c.124 1.085.317 1.976.545 2.582.115.306.228.51.324.63a.562.562 0 0 0 .068.072.898.898 0 0 0 .183-.244c.156-.27.313-.693.45-1.26.275-1.126.45-2.708.45-4.473 0-1.766-.175-3.347-.45-4.474-.137-.567-.294-.99-.45-1.26a.896.896 0 0 0-.183-.243.554.554 0 0 0-.066.07c-.095.116-.207.318-.321.619Zm.418 11.286h-.002.002ZM7.557 9.684a.5.5 0 0 0 0 .707l2.122 2.122a.5.5 0 0 0 .707 0l2.123-2.122a.5.5 0 0 0 0-.707L10.386 7.56a.5.5 0 0 0-.707 0L7.557 9.684Zm1.06.353 1.416 1.416 1.415-1.416-1.415-1.415-1.416 1.415Z"" fill=""currentColor""/>");
            builder.CloseElement();
            return;
        }

        if (hop.Type == HopType.Tailscale)
        {
            builder.OpenElement(0, "svg");
            builder.AddAttribute(1, "viewBox", "0 0 20 20");
            builder.AddAttribute(2, "width", "24");
            builder.AddAttribute(3, "height", "24");
            builder.AddAttribute(4, "class", "vpn-icon tailscale-icon");
            // Official Tailscale logo - 3x3 dot grid: middle row + center bottom solid, corners faded
            builder.AddMarkupContent(5, @"<ellipse cx=""2.45"" cy=""10.18"" rx=""2.45"" ry=""2.44"" fill=""currentColor""/><ellipse cx=""9.79"" cy=""10.18"" rx=""2.45"" ry=""2.44"" fill=""currentColor""/><ellipse cx=""17.13"" cy=""10.18"" rx=""2.45"" ry=""2.44"" fill=""currentColor""/><ellipse cx=""9.79"" cy=""17.51"" rx=""2.45"" ry=""2.44"" fill=""currentColor""/><ellipse opacity=""0.2"" cx=""2.45"" cy=""2.86"" rx=""2.45"" ry=""2.44"" fill=""currentColor""/><ellipse opacity=""0.2"" cx=""9.79"" cy=""2.86"" rx=""2.45"" ry=""2.44"" fill=""currentColor""/><ellipse opacity=""0.2"" cx=""17.13"" cy=""2.86"" rx=""2.45"" ry=""2.44"" fill=""currentColor""/><ellipse opacity=""0.2"" cx=""2.45"" cy=""17.51"" rx=""2.45"" ry=""2.44"" fill=""currentColor""/><ellipse opacity=""0.2"" cx=""17.13"" cy=""17.51"" rx=""2.45"" ry=""2.44"" fill=""currentColor""/>");
            builder.CloseElement();
            return;
        }

        if (hop.Type == HopType.Vpn)
        {
            builder.OpenElement(0, "img");
            builder.AddAttribute(1, "src", "/icons/shield-v2.png");
            builder.AddAttribute(2, "alt", "VPN");
            builder.AddAttribute(3, "class", "vpn-icon vpn-shield-icon");
            builder.CloseElement();
            return;
        }

        var model = hop.DeviceModel;

        // Show device icons for any device with a model name - onerror falls back to emoji
        if (!string.IsNullOrEmpty(model))
        {
            var iconPath = DeviceIcon.GetIconPath(model);
            if (iconPath != null)
            {
                builder.OpenElement(0, "img");
                builder.AddAttribute(1, "src", iconPath);
                builder.AddAttribute(2, "alt", model);
                builder.AddAttribute(3, "class", "device-icon device-icon-md");
                builder.AddAttribute(4, "loading", "lazy");
                builder.AddAttribute(5, "onerror", "this.style.display='none';this.nextSibling.style.display='inline'");
                builder.CloseElement();
                // Fallback span (hidden by default)
                builder.OpenElement(6, "span");
                builder.AddAttribute(7, "style", "display:none");
                builder.AddContent(8, GetHopIcon(hop.Type));
                builder.CloseElement();
                return;
            }
        }

        // Fallback to emoji
        builder.AddContent(0, GetHopIcon(hop.Type));
    };

    private void OnNotesKeyUp(KeyboardEventArgs e)
    {
        // Reset debounce timer on each keystroke
        _notesDebounceTimer?.Stop();
        _notesDebounceTimer?.Dispose();
        _notesSaved = false;

        _notesDebounceTimer = new System.Timers.Timer(800); // Longer debounce for notes
        _notesDebounceTimer.AutoReset = false;
        _notesDebounceTimer.Elapsed += async (s, e) => await InvokeAsync(SaveNotes);
        _notesDebounceTimer.Start();
    }

    private async Task SaveNotes()
    {
        if (Result == null || !OnNotesChanged.HasDelegate || _disposed) return;

        var newNotes = _notesInput?.Trim();
        var currentNotes = Result.Notes?.Trim();

        // Skip if notes haven't changed
        if (newNotes == currentNotes || (string.IsNullOrEmpty(newNotes) && string.IsNullOrEmpty(currentNotes)))
            return;

        _notesSaving = true;
        StateHasChanged();

        try
        {
            await OnNotesChanged.InvokeAsync((Result.Id, string.IsNullOrEmpty(newNotes) ? null : newNotes));
            Result.Notes = string.IsNullOrEmpty(newNotes) ? null : newNotes;
            _notesSaved = true;

            // Hide "Saved" after 2 seconds
            _notesSavedTimer?.Stop();
            _notesSavedTimer?.Dispose();
            _notesSavedTimer = new System.Timers.Timer(2000);
            _notesSavedTimer.AutoReset = false;
            _notesSavedTimer.Elapsed += async (s, e) =>
            {
                if (!_disposed)
                {
                    await InvokeAsync(() =>
                    {
                        _notesSaved = false;
                        StateHasChanged();
                    });
                }
            };
            _notesSavedTimer.Start();
        }
        finally
        {
            if (!_disposed)
            {
                _notesSaving = false;
                StateHasChanged();
            }
        }
    }

    private async Task HandleDelete()
    {
        if (Result == null) return;

        _deleting = true;
        try
        {
            await OnDelete.InvokeAsync(Result.Id);
        }
        finally
        {
            // Only reset if component is still mounted (delete may have removed us from DOM)
            if (!_disposed)
            {
                _deleting = false;
            }
        }
    }

    #region Directional Efficiency Helpers

    /// <summary>
    /// Get directional rates (TX/RX in Kbps) from result or path analysis.
    /// Returns null if no directional rates are available.
    /// </summary>
    private (long? rxKbps, long? txKbps) GetDirectionalRates()
    {
        // First check if rates are stored on the result (Wi-Fi clients)
        if (Result?.WifiRxRateKbps > 0 && Result?.WifiTxRateKbps > 0)
        {
            return (Result.WifiRxRateKbps, Result.WifiTxRateKbps);
        }

        // Fall back to extracting from path (mesh hops, WAN)
        return PathAnalysis?.GetDirectionalRatesFromPath() ?? (null, null);
    }

    /// <summary>
    /// Check if the Wi-Fi link is asymmetric (TX â‰  RX by more than 10%)
    /// </summary>
    private bool IsLinkAsymmetric()
    {
        var (rxKbps, txKbps) = GetDirectionalRates();
        return PathAnalysisResult.IsAsymmetric(rxKbps, txKbps);
    }

    /// <summary>
    /// Get directional efficiency data for display.
    /// Uses stored Wi-Fi TX/RX rates or mesh hop rates for accurate asymmetric efficiency.
    ///
    /// Direction mapping (critical):
    /// - FromDevice (â†“): Client SENDS â†’ AP RECEIVES â†’ uses RX rate
    /// - ToDevice (â†‘): Server SENDS â†’ AP TRANSMITS â†’ uses TX rate
    /// </summary>
    private (double fromMaxMbps, double toMaxMbps, double fromEff, double toEff, int overheadPct) GetDirectionalEfficiencyData()
    {
        if (PathAnalysis == null || Result == null)
        {
            return (0, 0, 0, 0, 6); // Default overhead
        }

        var (rxKbps, txKbps) = GetDirectionalRates();
        return PathAnalysis.GetDirectionalEfficiency(rxKbps, txKbps);
    }

    /// <summary>
    /// Get the efficiency tooltip text for a direction.
    /// ADDS to existing direction text, does not replace it.
    /// </summary>
    /// <param name="isFromDevice">True for FromDevice (â†“), false for ToDevice (â†‘)</param>
    private string GetEfficiencyTooltip(bool isFromDevice)
    {
        // Base direction text (preserved from original)
        var directionText = isFromDevice ? "From device to server" : "From server to device";

        if (PathAnalysis == null || Result == null)
            return directionText;

        var (fromMax, toMax, fromEff, toEff, overheadPct) = GetDirectionalEfficiencyData();

        // Get the relevant values for this direction
        var maxMbps = isFromDevice ? fromMax : toMax;
        var measuredMbps = isFromDevice ? DownloadMbps : UploadMbps;
        var efficiency = isFromDevice ? fromEff : toEff;

        // If we don't have valid data, return just the direction text
        if (maxMbps <= 0 || measuredMbps <= 0)
            return directionText;

        // Format with appropriate units - use Mbps until either value exceeds 9999
        // maxMbps is the link speed (PHY rate), overhead explains why you can't achieve 100%
        string measuredFormatted, maxFormatted, unit;
        if (measuredMbps > 9999 || maxMbps > 9999)
        {
            // Format with 2 decimals, trim trailing zeros (10.00 -> 10, 4.50 -> 4.5)
            measuredFormatted = $"{measuredMbps / 1000.0:F2}".TrimEnd('0').TrimEnd('.');
            maxFormatted = $"{maxMbps / 1000.0:F2}".TrimEnd('0').TrimEnd('.');
            unit = "Gbps";
        }
        else
        {
            // Show decimal for values < 10 to ensure 2+ significant digits
            measuredFormatted = measuredMbps < 10 ? $"{measuredMbps:F1}" : $"{measuredMbps:F0}";
            maxFormatted = maxMbps < 10 ? $"{maxMbps:F1}" : $"{maxMbps:F0}";
            unit = "Mbps";
        }
        return $"{directionText}. {measuredFormatted} of {maxFormatted} {unit} link (~{overheadPct}% overhead)";
    }

    /// <summary>
    /// Format the path max speed display, showing directional speeds if asymmetric.
    /// Returns MarkupString for colored arrows.
    /// </summary>
    private MarkupString FormatPathMaxSpeed()
    {
        if (PathAnalysis == null)
            return new MarkupString("0 Mbps");

        if (!IsLinkAsymmetric())
        {
            return new MarkupString(FormatSpeed(PathAnalysis.Path.TheoreticalMaxMbps));
        }

        // Asymmetric: show both directions with colored arrows matching speed-results
        var (fromMax, toMax, _, _, _) = GetDirectionalEfficiencyData();

        // Use Gbps if both are >= 1000, otherwise Mbps
        string fromVal, toVal, unit;
        if (fromMax >= 1000 && toMax >= 1000)
        {
            fromVal = $"{fromMax / 1000.0:F1}";
            toVal = $"{toMax / 1000.0:F1}";
            unit = "Gbps";
        }
        else
        {
            fromVal = $"{fromMax:F0}";
            toVal = $"{toMax:F0}";
            unit = "Mbps";
        }

        // Use download/upload colors: download (from device) = blue, upload (to device) = green
        return new MarkupString($"<span class=\"speed-from\">â†“{fromVal}</span> <span class=\"speed-to\">â†‘{toVal}</span> {unit}");
    }

    /// <summary>
    /// Format the bottleneck description, showing directional speeds (Rx / Tx) if asymmetric.
    /// Generated on the fly to support existing test results.
    /// </summary>
    private string FormatBottleneckDescription()
    {
        if (PathAnalysis == null || string.IsNullOrEmpty(PathAnalysis.Path.BottleneckDescription))
            return "";

        var (rxKbps, txKbps) = GetDirectionalRates();

        // If we have directional rates and they differ significantly, show both
        if (rxKbps.HasValue && txKbps.HasValue &&
            rxKbps.Value > 0 && txKbps.Value > 0 &&
            PathAnalysisResult.IsAsymmetric(rxKbps, txKbps))
        {
            var rxMbps = rxKbps.Value / 1000.0;
            var txMbps = txKbps.Value / 1000.0;

            // Format speed as "Rx / Tx" with appropriate unit
            string speedStr;
            if (rxMbps >= 1000 && txMbps >= 1000)
            {
                var rxGbps = rxMbps / 1000.0;
                var txGbps = txMbps / 1000.0;
                speedStr = $"{rxGbps:F1} / {txGbps:F1} Gbps";
            }
            else
            {
                speedStr = $"{rxMbps:F0} / {txMbps:F0} Mbps";
            }

            // Extract device info from existing description (after " at ")
            var description = PathAnalysis.Path.BottleneckDescription;
            var atIndex = description.IndexOf(" at ", StringComparison.Ordinal);
            var devicePart = atIndex >= 0 ? description.Substring(atIndex) : "";

            return $"{speedStr} link{devicePart}";
        }

        // Fall back to existing description for symmetric links
        return PathAnalysis.Path.BottleneckDescription;
    }

    /// <summary>
    /// Get the unit (Gbps or Mbps) used for asymmetric display, for tooltip consistency.
    /// </summary>
    private (bool useGbps, string unit) GetAsymmetricUnit()
    {
        if (PathAnalysis == null || !IsLinkAsymmetric())
            return (false, "Mbps");

        var (fromMax, toMax, _, _, _) = GetDirectionalEfficiencyData();
        var useGbps = fromMax >= 1000 && toMax >= 1000;
        return (useGbps, useGbps ? "Gbps" : "Mbps");
    }

    /// <summary>
    /// Get the display efficiency percentage for a direction.
    /// Uses directional calculation if Wi-Fi rates are available.
    /// </summary>
    private double GetDisplayEfficiency(bool isFromDevice)
    {
        if (PathAnalysis == null)
            return 0;

        // If we have directional rates (Wi-Fi client or mesh), use directional efficiency
        var (rxKbps, txKbps) = GetDirectionalRates();
        if (rxKbps > 0 && txKbps > 0)
        {
            var (_, _, fromEff, toEff, _) = GetDirectionalEfficiencyData();
            return isFromDevice ? fromEff : toEff;
        }

        // Fall back to symmetric efficiency
        return isFromDevice ? PathAnalysis.FromDeviceEfficiencyPercent : PathAnalysis.ToDeviceEfficiencyPercent;
    }

    /// <summary>
    /// Get the performance grade for a direction based on efficiency.
    /// </summary>
    private PerformanceGrade GetDisplayGrade(bool isFromDevice)
    {
        var efficiency = GetDisplayEfficiency(isFromDevice);
        return efficiency switch
        {
            >= 90 => PerformanceGrade.Excellent,
            >= 75 => PerformanceGrade.Good,
            >= 50 => PerformanceGrade.Fair,
            >= 25 => PerformanceGrade.Poor,
            _ => PerformanceGrade.Critical
        };
    }

    #endregion

    public void Dispose()
    {
        _disposed = true;
        _notesDebounceTimer?.Dispose();
        _notesSavedTimer?.Dispose();
    }
}
