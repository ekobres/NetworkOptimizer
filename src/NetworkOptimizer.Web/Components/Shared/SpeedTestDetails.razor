@using NetworkOptimizer.Storage.Models
@using NetworkOptimizer.UniFi
@using NetworkOptimizer.UniFi.Models
@using NetworkOptimizer.Web.Services
@using NetworkOptimizer.Web.Components.Shared

<div class="speed-results">
    <div class="speed-result download">
        <div class="speed-icon">
            <svg viewBox="0 0 24 24" width="32" height="32">
                <path d="M12 4v12m0 0l-4-4m4 4l4-4M5 18h14" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
        </div>
        <div class="speed-details">
            <div class="speed-label">From Device <span class="tooltip-icon tooltip-icon-sm" data-tooltip="Data transferred from the tested device to this server">?</span></div>
            <div class="speed-value">@DownloadMbps.ToString("F1") <span class="speed-unit">Mbps</span></div>
            <div class="speed-meta">@FormatBytes(DownloadBytes) transferred</div>
        </div>
    </div>
    <div class="speed-result upload">
        <div class="speed-icon">
            <svg viewBox="0 0 24 24" width="32" height="32">
                <path d="M12 20V8m0 0l4 4m-4-4l-4 4M5 6h14" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
        </div>
        <div class="speed-details">
            <div class="speed-label">To Device <span class="tooltip-icon tooltip-icon-sm" data-tooltip="Data transferred to the tested device from this server">?</span></div>
            <div class="speed-value">@UploadMbps.ToString("F1") <span class="speed-unit">Mbps</span></div>
            <div class="speed-meta">@FormatBytes(UploadBytes) transferred</div>
        </div>
    </div>
</div>
@if (DownloadRetransmits > 0 || UploadRetransmits > 0)
{
    <div class="retransmits-info">
        <small>Retransmits: @DownloadRetransmits from / @UploadRetransmits to</small>
    </div>
}
<div class="test-details">
    <span>Device: @DeviceName (@DeviceHost)</span>
    <span>Duration: @DurationSeconds seconds</span>
    <span>Streams: @ParallelStreams parallel</span>
    <span>Time: @TestTime.ToLocalTime().ToString("g")</span>
</div>

@if (PathAnalysis != null)
{
    <div class="path-analysis">
        @if (PathAnalysis.Path.IsValid)
        {
            <div class="path-summary">
                <div class="path-max-speed">
                    <span class="speed-value">@FormatSpeed(PathAnalysis.Path.TheoreticalMaxMbps)</span>
                    <span class="speed-label">max</span>
                </div>
                <div class="efficiency-grades">
                    <div class="grade-item">
                        <span class="grade-badge @GetGradeClass(PathAnalysis.FromDeviceGrade)" data-tooltip="From device to server">
                            ‚Üì @PathAnalysis.FromDeviceEfficiencyPercent.ToString("F0")%
                        </span>
                    </div>
                    <div class="grade-item">
                        <span class="grade-badge @GetGradeClass(PathAnalysis.ToDeviceGrade)" data-tooltip="From server to device">
                            ‚Üë @PathAnalysis.ToDeviceEfficiencyPercent.ToString("F0")%
                        </span>
                    </div>
                </div>
            </div>

            @if (PathAnalysis.Path.Hops.Count > 0)
            {
                <div class="path-visualization">
                    @for (var i = 0; i < PathAnalysis.Path.Hops.Count; i++)
                    {
                        var hop = PathAnalysis.Path.Hops[i];
                        <div class="path-hop @(hop.IsBottleneck ? "bottleneck" : "") @GetHopTypeClass(hop.Type)">
                            <span class="hop-icon">@GetHopIconMarkup(hop)</span>
                            <span class="hop-name">@hop.DeviceName</span>
                        </div>
                        @if (i < PathAnalysis.Path.Hops.Count - 1)
                        {
                            @* Speed goes on the connector (link between devices) *@
                            @* Use next hop's ingress speed (the link TO the next device) *@
                            var nextHop = PathAnalysis.Path.Hops[i + 1];
                            var linkSpeed = nextHop.IngressSpeedMbps > 0 ? nextHop.IngressSpeedMbps : hop.EgressSpeedMbps;
                            @* Mark as bottleneck if this link's speed equals the path minimum and there's a real bottleneck *@
                            var isBottleneckLink = PathAnalysis.Path.HasRealBottleneck &&
                                                   linkSpeed > 0 &&
                                                   linkSpeed == PathAnalysis.Path.TheoreticalMaxMbps;
                            @* Check if this link is wireless (current hop egress or next hop ingress) *@
                            var isWirelessLink = hop.IsWirelessEgress || nextHop.IsWirelessIngress;
                            <div class="path-connector @(isBottleneckLink ? "bottleneck" : "") @(isWirelessLink ? "wireless" : "")">
                                @if (isWirelessLink)
                                {
                                    var wifiTooltip = GetWifiTooltip(hop, nextHop);
                                    <span class="wireless-icon" data-tooltip="@wifiTooltip">üì∂</span>
                                }
                                <span class="connector-line"></span>
                                @if (linkSpeed > 0)
                                {
                                    <span class="connector-speed">@FormatSpeed(linkSpeed)</span>
                                }
                            </div>
                        }
                    }
                </div>
            }

            @if (PathAnalysis.Path.HasRealBottleneck && !string.IsNullOrEmpty(PathAnalysis.Path.BottleneckDescription))
            {
                <div class="bottleneck-warning">
                    ‚ö†Ô∏è @PathAnalysis.Path.BottleneckDescription
                </div>
            }

            @if (PathAnalysis.Path.RequiresRouting)
            {
                <div class="routing-badge">
                    üîÄ Inter-VLAN via @(PathAnalysis.Path.GatewayDevice ?? "gateway")
                </div>
            }
        }
        else
        {
            <div class="path-error">
                @(PathAnalysis.Path.ErrorMessage ?? "Path analysis unavailable")
            </div>
        }

        @if (PathAnalysis.Insights.Count > 0 || PathAnalysis.Recommendations.Count > 0)
        {
            <div class="path-notes">
                @foreach (var insight in PathAnalysis.Insights)
                {
                    <div class="note insight">üí° @insight</div>
                }
                @foreach (var rec in PathAnalysis.Recommendations)
                {
                    <div class="note recommendation">üìà @rec</div>
                }
            </div>
        }
    </div>
}

@code {
    [Parameter] public double DownloadMbps { get; set; }
    [Parameter] public double UploadMbps { get; set; }
    [Parameter] public long DownloadBytes { get; set; }
    [Parameter] public long UploadBytes { get; set; }
    [Parameter] public int DownloadRetransmits { get; set; }
    [Parameter] public int UploadRetransmits { get; set; }
    [Parameter] public string DeviceName { get; set; } = "";
    [Parameter] public string DeviceHost { get; set; } = "";
    [Parameter] public int DurationSeconds { get; set; }
    [Parameter] public int ParallelStreams { get; set; }
    [Parameter] public DateTime TestTime { get; set; }

    /// <summary>
    /// Path analysis result (set automatically when using Result parameter)
    /// </summary>
    [Parameter] public PathAnalysisResult? PathAnalysis { get; set; }

    /// <summary>
    /// Convenience parameter to set all values from an Iperf3Result
    /// </summary>
    [Parameter] public Iperf3Result? Result { get; set; }

    /// <summary>
    /// Convenience parameter to set all values from a GatewaySpeedTestResult
    /// </summary>
    [Parameter] public GatewaySpeedTestResult? GatewayResult { get; set; }

    // Track previous Result ID to detect when Result changes
    private int? _previousResultId;

    protected override void OnParametersSet()
    {
        if (Result != null)
        {
            // Detect if Result changed (different test)
            bool resultChanged = _previousResultId != Result.Id;
            _previousResultId = Result.Id;

            DownloadMbps = Result.DownloadMbps;
            UploadMbps = Result.UploadMbps;
            DownloadBytes = Result.DownloadBytes;
            UploadBytes = Result.UploadBytes;
            DownloadRetransmits = Result.DownloadRetransmits;
            UploadRetransmits = Result.UploadRetransmits;
            DeviceName = Result.DeviceName ?? "";
            DeviceHost = Result.DeviceHost;
            DurationSeconds = Result.DurationSeconds;
            ParallelStreams = Result.ParallelStreams;
            TestTime = Result.TestTime;

            // Sync PathAnalysis from Result when Result changes
            // This ensures we don't show stale analysis from a previous test
            if (resultChanged)
            {
                PathAnalysis = Result.PathAnalysis;
            }
            else
            {
                // Only use Result.PathAnalysis if no separate PathAnalysis was passed
                PathAnalysis ??= Result.PathAnalysis;
            }
        }
        else if (GatewayResult != null)
        {
            DownloadMbps = GatewayResult.DownloadMbps;
            UploadMbps = GatewayResult.UploadMbps;
            DownloadBytes = GatewayResult.DownloadBytes;
            UploadBytes = GatewayResult.UploadBytes;
            DownloadRetransmits = GatewayResult.DownloadRetransmits;
            UploadRetransmits = GatewayResult.UploadRetransmits;
            DeviceName = "Gateway";
            DeviceHost = GatewayResult.GatewayHost ?? "";
            DurationSeconds = GatewayResult.DurationSeconds;
            ParallelStreams = GatewayResult.ParallelStreams;
            TestTime = GatewayResult.TestTime;
        }
    }

    private string FormatBytes(long bytes)
    {
        if (bytes < 1024)
            return $"{bytes} B";
        if (bytes < 1024 * 1024)
            return $"{bytes / 1024.0:F1} KB";
        if (bytes < 1024 * 1024 * 1024)
            return $"{bytes / (1024.0 * 1024.0):F1} MB";
        return $"{bytes / (1024.0 * 1024.0 * 1024.0):F2} GB";
    }

    private string FormatSpeed(int mbps)
    {
        if (mbps >= 1000)
        {
            var gbps = mbps / 1000.0;
            return gbps % 1 == 0 ? $"{(int)gbps} Gbps" : $"{gbps:F1} Gbps";
        }
        return $"{mbps} Mbps";
    }

    private string GetGradeClass(PerformanceGrade grade) => grade switch
    {
        PerformanceGrade.Excellent => "grade-excellent",
        PerformanceGrade.Good => "grade-good",
        PerformanceGrade.Fair => "grade-fair",
        PerformanceGrade.Poor => "grade-poor",
        PerformanceGrade.Critical => "grade-critical",
        _ => ""
    };

    private string GetHopTypeClass(HopType type) => type switch
    {
        HopType.Client => "hop-client",
        HopType.WirelessClient => "hop-client",
        HopType.Switch => "hop-switch",
        HopType.AccessPoint => "hop-ap",
        HopType.Gateway => "hop-gateway",
        HopType.Server => "hop-server",
        _ => ""
    };

    private string GetHopIcon(HopType type) => type switch
    {
        HopType.Client => "üñ•Ô∏è",
        HopType.WirelessClient => "üíª",
        HopType.Switch => "üîÄ",
        HopType.AccessPoint => "üì∂",
        HopType.Gateway => "üåê",
        HopType.Server => "üñ•Ô∏è",
        _ => "‚Ä¢"
    };

    /// <summary>
    /// Get Wi-Fi signal tooltip content from the hop or Result
    /// </summary>
    private string GetWifiTooltip(NetworkHop hop, NetworkHop nextHop)
    {
        // Determine if this is the client's wireless connection (first hop is WirelessClient)
        // or a mesh/bridge wireless link
        var isClientWireless = hop.Type == HopType.WirelessClient || nextHop.Type == HopType.WirelessClient;

        // Get band from hop (mesh) or result (client)
        string? band = null;
        if (hop.IsWirelessEgress && !string.IsNullOrEmpty(hop.WirelessEgressBand))
            band = hop.WirelessEgressBand;
        else if (nextHop.IsWirelessIngress && !string.IsNullOrEmpty(nextHop.WirelessIngressBand))
            band = nextHop.WirelessIngressBand;

        // For client wireless, also show signal/noise from Result
        if (isClientWireless && Result != null)
        {
            // Check for MLO (Multi-Link Operation) - use unified styling
            if (Result.WifiIsMlo && !string.IsNullOrEmpty(Result.WifiMloLinksJson))
            {
                return BuildMloTooltip();
            }

            // Single-link wireless - use same styled format as MLO
            var lines = new List<string>();
            var clientBand = !string.IsNullOrEmpty(Result.WifiRadio) ? Result.WifiRadio : band;

            // Header with protocol
            if (!string.IsNullOrEmpty(Result.WifiRadioProto))
                lines.Add($"<div class='wifi-tooltip-header'>Wi-Fi {FormatRadioProto(Result.WifiRadioProto, clientBand)}</div>");

            // RX/TX speeds (RX first = "from device", TX = "to device")
            if (Result.WifiTxRateKbps.HasValue || Result.WifiRxRateKbps.HasValue)
            {
                var speedParts = new List<string>();
                if (Result.WifiRxRateKbps.HasValue && Result.WifiRxRateKbps.Value > 0)
                    speedParts.Add($"<span class='wifi-speed-rx'>RX {Result.WifiRxRateKbps.Value / 1000} Mbps</span>");
                if (Result.WifiTxRateKbps.HasValue && Result.WifiTxRateKbps.Value > 0)
                    speedParts.Add($"<span class='wifi-speed-tx'>TX {Result.WifiTxRateKbps.Value / 1000} Mbps</span>");
                if (speedParts.Count > 0)
                    lines.Add($"<div class='wifi-tooltip-row wifi-tooltip-speed'>{string.Join(" ¬∑ ", speedParts)}</div>");
            }

            // Link info with band badge
            if (!string.IsNullOrEmpty(clientBand) || Result.WifiChannel.HasValue)
            {
                var linkParts = new List<string>();
                if (!string.IsNullOrEmpty(clientBand))
                    linkParts.Add($"<span class='wifi-band-badge wifi-band-{clientBand}'>{FormatRadioBand(clientBand)}</span>");
                if (Result.WifiChannel.HasValue)
                    linkParts.Add($"Ch {Result.WifiChannel.Value}");
                lines.Add($"<div class='wifi-tooltip-link'>{string.Join(" ", linkParts)}</div>");
            }

            // Signal line
            if (Result.WifiSignalDbm.HasValue)
            {
                var sigParts = new List<string> { $"{Result.WifiSignalDbm.Value} dBm" };
                if (Result.WifiNoiseDbm.HasValue)
                    sigParts.Add($"SNR {Result.WifiSignalDbm.Value - Result.WifiNoiseDbm.Value} dB");
                lines.Add($"<div class='wifi-tooltip-link-signal'>{string.Join(" ¬∑ ", sigParts)}</div>");
            }

            return lines.Count > 0 ? string.Join("", lines) : "Wireless connection";
        }

        // For mesh/bridge wireless - use same styled format
        var meshHop = hop.IsWirelessEgress ? hop : nextHop;
        var lines2 = new List<string>();

        lines2.Add("<div class='wifi-tooltip-header'>Wireless Mesh</div>");

        // RX/TX speeds (RX first = "from device", TX = "to device")
        if (meshHop.WirelessTxRateMbps.HasValue || meshHop.WirelessRxRateMbps.HasValue)
        {
            var speedParts = new List<string>();
            if (meshHop.WirelessRxRateMbps.HasValue)
                speedParts.Add($"<span class='wifi-speed-rx'>RX {meshHop.WirelessRxRateMbps.Value} Mbps</span>");
            if (meshHop.WirelessTxRateMbps.HasValue)
                speedParts.Add($"<span class='wifi-speed-tx'>TX {meshHop.WirelessTxRateMbps.Value} Mbps</span>");
            lines2.Add($"<div class='wifi-tooltip-row wifi-tooltip-speed'>{string.Join(" ¬∑ ", speedParts)}</div>");
        }

        // Link info with band badge
        if (!string.IsNullOrEmpty(band) || meshHop.WirelessChannel.HasValue)
        {
            var linkParts = new List<string>();
            if (!string.IsNullOrEmpty(band))
                linkParts.Add($"<span class='wifi-band-badge wifi-band-{band}'>{FormatRadioBand(band)}</span>");
            if (meshHop.WirelessChannel.HasValue)
                linkParts.Add($"Ch {meshHop.WirelessChannel.Value}");
            lines2.Add($"<div class='wifi-tooltip-link'>{string.Join(" ", linkParts)}</div>");
        }

        // Signal line
        if (meshHop.WirelessSignalDbm.HasValue)
        {
            var sigParts = new List<string> { $"{meshHop.WirelessSignalDbm.Value} dBm" };
            if (meshHop.WirelessNoiseDbm.HasValue)
                sigParts.Add($"SNR {meshHop.WirelessSignalDbm.Value - meshHop.WirelessNoiseDbm.Value} dB");
            lines2.Add($"<div class='wifi-tooltip-link-signal'>{string.Join(" ¬∑ ", sigParts)}</div>");
        }

        return lines2.Count > 1 ? string.Join("", lines2) : "Wireless mesh";
    }

    /// <summary>
    /// Build tooltip content for MLO (Multi-Link Operation) Wi-Fi 7 connections
    /// </summary>
    private string BuildMloTooltip()
    {
        if (Result == null || string.IsNullOrEmpty(Result.WifiMloLinksJson))
            return "Wi-Fi 7 MLO";

        try
        {
            var links = System.Text.Json.JsonSerializer.Deserialize<List<MloLinkData>>(Result.WifiMloLinksJson);
            if (links == null || links.Count == 0)
                return "Wi-Fi 7 MLO";

            var lines = new List<string>();

            // Header with Wi-Fi 7 MLO badge
            lines.Add("<div class='wifi-tooltip-header'>Wi-Fi 7 (be) ¬∑ MLO</div>");

            // Sum link speeds
            var totalTxMbps = links.Where(l => l.txRate.HasValue).Sum(l => l.txRate!.Value / 1000.0);
            var totalRxMbps = links.Where(l => l.rxRate.HasValue).Sum(l => l.rxRate!.Value / 1000.0);

            if (totalTxMbps > 0 || totalRxMbps > 0)
            {
                var speedParts = new List<string>();
                if (totalRxMbps > 0) speedParts.Add($"<span class='wifi-speed-rx'>RX {totalRxMbps:F0} Mbps</span>");
                if (totalTxMbps > 0) speedParts.Add($"<span class='wifi-speed-tx'>TX {totalTxMbps:F0} Mbps</span>");
                lines.Add($"<div class='wifi-tooltip-row wifi-tooltip-speed'>{string.Join(" ¬∑ ", speedParts)}</div>");
            }

            // Divider
            lines.Add("<div class='wifi-tooltip-divider'></div>");

            // Each link
            foreach (var link in links.OrderByDescending(l => l.channelWidth ?? 0))
            {
                var linkParts = new List<string>();

                // Band badge
                if (!string.IsNullOrEmpty(link.radio))
                    linkParts.Add($"<span class='wifi-band-badge wifi-band-{link.radio}'>{FormatRadioBand(link.radio)}</span>");

                // Channel/width
                if (link.channel.HasValue)
                {
                    var chInfo = $"Ch {link.channel.Value}";
                    if (link.channelWidth.HasValue)
                        chInfo += $" ({link.channelWidth.Value} MHz)";
                    linkParts.Add(chInfo);
                }

                lines.Add($"<div class='wifi-tooltip-link'>{string.Join(" ", linkParts)}</div>");

                // Per-link RX/TX rates (RX first = "from device", TX = "to device")
                if (link.txRate.HasValue || link.rxRate.HasValue)
                {
                    var linkSpeedParts = new List<string>();
                    if (link.rxRate.HasValue)
                        linkSpeedParts.Add($"<span class='wifi-speed-rx'>RX {link.rxRate.Value / 1000} Mbps</span>");
                    if (link.txRate.HasValue)
                        linkSpeedParts.Add($"<span class='wifi-speed-tx'>TX {link.txRate.Value / 1000} Mbps</span>");
                    lines.Add($"<div class='wifi-tooltip-link-speed'>{string.Join(" ¬∑ ", linkSpeedParts)}</div>");
                }

                // Signal for this link
                if (link.signal.HasValue)
                {
                    var sigParts = new List<string> { $"{link.signal.Value} dBm" };
                    if (link.signal.HasValue && link.noise.HasValue)
                        sigParts.Add($"SNR {link.signal.Value - link.noise.Value} dB");
                    lines.Add($"<div class='wifi-tooltip-link-signal'>{string.Join(" ¬∑ ", sigParts)}</div>");
                }
            }

            return string.Join("", lines);
        }
        catch
        {
            return "Wi-Fi 7 MLO";
        }
    }

    // DTO for deserializing MLO link JSON
    private record MloLinkData(
        string? radio,
        int? channel,
        int? channelWidth,
        int? signal,
        int? noise,
        long? txRate,
        long? rxRate
    );

    private string FormatRadioBand(string? radio) => RadioFormatHelper.FormatBand(radio);

    private string FormatRadioProto(string? proto, string? radio = null) =>
        RadioFormatHelper.FormatProtocolSuffix(proto, radio);

    /// <summary>
    /// Render a device icon for the path hop, falling back to emoji if no icon available
    /// </summary>
    private RenderFragment GetHopIconMarkup(NetworkHop hop) => builder =>
    {
        var model = hop.DeviceModel;

        // Show device icons for any device with a model name - onerror falls back to emoji
        if (!string.IsNullOrEmpty(model))
        {
            var iconPath = DeviceIcon.GetIconPath(model);
            if (iconPath != null)
            {
                builder.OpenElement(0, "img");
                builder.AddAttribute(1, "src", iconPath);
                builder.AddAttribute(2, "alt", model);
                builder.AddAttribute(3, "class", "device-icon device-icon-md");
                builder.AddAttribute(4, "loading", "lazy");
                builder.AddAttribute(5, "onerror", "this.style.display='none';this.nextSibling.style.display='inline'");
                builder.CloseElement();
                // Fallback span (hidden by default)
                builder.OpenElement(6, "span");
                builder.AddAttribute(7, "style", "display:none");
                builder.AddContent(8, GetHopIcon(hop.Type));
                builder.CloseElement();
                return;
            }
        }

        // Fallback to emoji
        builder.AddContent(0, GetHopIcon(hop.Type));
    };
}
