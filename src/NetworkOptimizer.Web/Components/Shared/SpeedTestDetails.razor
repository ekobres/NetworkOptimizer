@using NetworkOptimizer.Storage.Models
@using NetworkOptimizer.UniFi
@using NetworkOptimizer.UniFi.Models
@using NetworkOptimizer.Web.Services
@using NetworkOptimizer.Web.Components.Shared

<div class="speed-results">
    <div class="speed-result download">
        <div class="speed-icon">
            <svg viewBox="0 0 24 24" width="32" height="32">
                <path d="M12 4v12m0 0l-4-4m4 4l4-4M5 18h14" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
        </div>
        <div class="speed-details">
            <div class="speed-label">From Device <span class="tooltip-icon tooltip-icon-sm" data-tooltip="Data transferred from the tested device to this server">?</span></div>
            <div class="speed-value">@DownloadMbps.ToString("F1") <span class="speed-unit">Mbps</span></div>
            <div class="speed-meta">@FormatBytes(DownloadBytes) transferred</div>
        </div>
    </div>
    <div class="speed-result upload">
        <div class="speed-icon">
            <svg viewBox="0 0 24 24" width="32" height="32">
                <path d="M12 20V8m0 0l4 4m-4-4l-4 4M5 6h14" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
        </div>
        <div class="speed-details">
            <div class="speed-label">To Device <span class="tooltip-icon tooltip-icon-sm" data-tooltip="Data transferred to the tested device from this server">?</span></div>
            <div class="speed-value">@UploadMbps.ToString("F1") <span class="speed-unit">Mbps</span></div>
            <div class="speed-meta">@FormatBytes(UploadBytes) transferred</div>
        </div>
    </div>
</div>
@if (DownloadRetransmits > 0 || UploadRetransmits > 0)
{
    <div class="retransmits-info">
        <small>Retransmits: @DownloadRetransmits from / @UploadRetransmits to</small>
    </div>
}
<div class="test-details">
    <span>Device: @DeviceName (@DeviceHost)</span>
    <span>Duration: @DurationSeconds seconds</span>
    <span>Streams: @ParallelStreams parallel</span>
    <span>Time: @TestTime.ToLocalTime().ToString("g")</span>
</div>

@if (PathAnalysis != null)
{
    <div class="path-analysis">
        @if (PathAnalysis.Path.IsValid)
        {
            <div class="path-summary">
                <div class="path-max-speed">
                    <span class="speed-value">@FormatSpeed(PathAnalysis.Path.TheoreticalMaxMbps)</span>
                    <span class="speed-label">max</span>
                </div>
                <div class="efficiency-grades">
                    <div class="grade-item">
                        <span class="grade-badge @GetGradeClass(PathAnalysis.FromDeviceGrade)" data-tooltip="From device to server">
                            ‚Üì @PathAnalysis.FromDeviceEfficiencyPercent.ToString("F0")%
                        </span>
                    </div>
                    <div class="grade-item">
                        <span class="grade-badge @GetGradeClass(PathAnalysis.ToDeviceGrade)" data-tooltip="From server to device">
                            ‚Üë @PathAnalysis.ToDeviceEfficiencyPercent.ToString("F0")%
                        </span>
                    </div>
                </div>
            </div>

            @if (PathAnalysis.Path.Hops.Count > 0)
            {
                <div class="path-visualization">
                    @for (var i = 0; i < PathAnalysis.Path.Hops.Count; i++)
                    {
                        var hop = PathAnalysis.Path.Hops[i];
                        <div class="path-hop @(hop.IsBottleneck ? "bottleneck" : "") @GetHopTypeClass(hop.Type)">
                            <span class="hop-icon">@GetHopIconMarkup(hop)</span>
                            <span class="hop-name">@hop.DeviceName</span>
                        </div>
                        @if (i < PathAnalysis.Path.Hops.Count - 1)
                        {
                            @* Speed goes on the connector (link between devices) *@
                            @* Use next hop's ingress speed (the link TO the next device) *@
                            var nextHop = PathAnalysis.Path.Hops[i + 1];
                            var linkSpeed = nextHop.IngressSpeedMbps > 0 ? nextHop.IngressSpeedMbps : hop.EgressSpeedMbps;
                            @* Mark as bottleneck if this link's speed equals the path minimum and there's a real bottleneck *@
                            var isBottleneckLink = PathAnalysis.Path.HasRealBottleneck &&
                                                   linkSpeed > 0 &&
                                                   linkSpeed == PathAnalysis.Path.TheoreticalMaxMbps;
                            @* Check if this link is wireless (current hop egress or next hop ingress) *@
                            var isWirelessLink = hop.IsWirelessEgress || nextHop.IsWirelessIngress;
                            <div class="path-connector @(isBottleneckLink ? "bottleneck" : "") @(isWirelessLink ? "wireless" : "")">
                                <span class="connector-line"></span>
                                @if (linkSpeed > 0)
                                {
                                    <span class="connector-speed">@FormatSpeed(linkSpeed)</span>
                                }
                            </div>
                        }
                    }
                </div>
            }

            @if (PathAnalysis.Path.HasRealBottleneck && !string.IsNullOrEmpty(PathAnalysis.Path.BottleneckDescription))
            {
                <div class="bottleneck-warning">
                    ‚ö†Ô∏è @PathAnalysis.Path.BottleneckDescription
                </div>
            }

            @if (PathAnalysis.Path.RequiresRouting)
            {
                <div class="routing-badge">
                    üîÄ Inter-VLAN via @(PathAnalysis.Path.GatewayDevice ?? "gateway")
                </div>
            }
        }
        else
        {
            <div class="path-error">
                @(PathAnalysis.Path.ErrorMessage ?? "Path analysis unavailable")
            </div>
        }

        @if (PathAnalysis.Insights.Count > 0 || PathAnalysis.Recommendations.Count > 0)
        {
            <div class="path-notes">
                @foreach (var insight in PathAnalysis.Insights)
                {
                    <div class="note insight">üí° @insight</div>
                }
                @foreach (var rec in PathAnalysis.Recommendations)
                {
                    <div class="note recommendation">üìà @rec</div>
                }
            </div>
        }
    </div>
}

@code {
    [Parameter] public double DownloadMbps { get; set; }
    [Parameter] public double UploadMbps { get; set; }
    [Parameter] public long DownloadBytes { get; set; }
    [Parameter] public long UploadBytes { get; set; }
    [Parameter] public int DownloadRetransmits { get; set; }
    [Parameter] public int UploadRetransmits { get; set; }
    [Parameter] public string DeviceName { get; set; } = "";
    [Parameter] public string DeviceHost { get; set; } = "";
    [Parameter] public int DurationSeconds { get; set; }
    [Parameter] public int ParallelStreams { get; set; }
    [Parameter] public DateTime TestTime { get; set; }

    /// <summary>
    /// Path analysis result (set automatically when using Result parameter)
    /// </summary>
    [Parameter] public PathAnalysisResult? PathAnalysis { get; set; }

    /// <summary>
    /// Convenience parameter to set all values from an Iperf3Result
    /// </summary>
    [Parameter] public Iperf3Result? Result { get; set; }

    /// <summary>
    /// Convenience parameter to set all values from a GatewaySpeedTestResult
    /// </summary>
    [Parameter] public GatewaySpeedTestResult? GatewayResult { get; set; }

    // Track previous Result ID to detect when Result changes
    private int? _previousResultId;

    protected override void OnParametersSet()
    {
        if (Result != null)
        {
            // Detect if Result changed (different test)
            bool resultChanged = _previousResultId != Result.Id;
            _previousResultId = Result.Id;

            DownloadMbps = Result.DownloadMbps;
            UploadMbps = Result.UploadMbps;
            DownloadBytes = Result.DownloadBytes;
            UploadBytes = Result.UploadBytes;
            DownloadRetransmits = Result.DownloadRetransmits;
            UploadRetransmits = Result.UploadRetransmits;
            DeviceName = Result.DeviceName ?? "";
            DeviceHost = Result.DeviceHost;
            DurationSeconds = Result.DurationSeconds;
            ParallelStreams = Result.ParallelStreams;
            TestTime = Result.TestTime;

            // Sync PathAnalysis from Result when Result changes
            // This ensures we don't show stale analysis from a previous test
            if (resultChanged)
            {
                PathAnalysis = Result.PathAnalysis;
            }
            else
            {
                // Only use Result.PathAnalysis if no separate PathAnalysis was passed
                PathAnalysis ??= Result.PathAnalysis;
            }
        }
        else if (GatewayResult != null)
        {
            DownloadMbps = GatewayResult.DownloadMbps;
            UploadMbps = GatewayResult.UploadMbps;
            DownloadBytes = GatewayResult.DownloadBytes;
            UploadBytes = GatewayResult.UploadBytes;
            DownloadRetransmits = GatewayResult.DownloadRetransmits;
            UploadRetransmits = GatewayResult.UploadRetransmits;
            DeviceName = "Gateway";
            DeviceHost = GatewayResult.GatewayHost ?? "";
            DurationSeconds = GatewayResult.DurationSeconds;
            ParallelStreams = GatewayResult.ParallelStreams;
            TestTime = GatewayResult.TestTime;
        }
    }

    private string FormatBytes(long bytes)
    {
        if (bytes < 1024)
            return $"{bytes} B";
        if (bytes < 1024 * 1024)
            return $"{bytes / 1024.0:F1} KB";
        if (bytes < 1024 * 1024 * 1024)
            return $"{bytes / (1024.0 * 1024.0):F1} MB";
        return $"{bytes / (1024.0 * 1024.0 * 1024.0):F2} GB";
    }

    private string FormatSpeed(int mbps)
    {
        if (mbps >= 1000)
        {
            var gbps = mbps / 1000.0;
            return gbps % 1 == 0 ? $"{(int)gbps} Gbps" : $"{gbps:F1} Gbps";
        }
        return $"{mbps} Mbps";
    }

    private string GetGradeClass(PerformanceGrade grade) => grade switch
    {
        PerformanceGrade.Excellent => "grade-excellent",
        PerformanceGrade.Good => "grade-good",
        PerformanceGrade.Fair => "grade-fair",
        PerformanceGrade.Poor => "grade-poor",
        PerformanceGrade.Critical => "grade-critical",
        _ => ""
    };

    private string GetHopTypeClass(HopType type) => type switch
    {
        HopType.Client => "hop-client",
        HopType.WirelessClient => "hop-client",
        HopType.Switch => "hop-switch",
        HopType.AccessPoint => "hop-ap",
        HopType.Gateway => "hop-gateway",
        HopType.Server => "hop-server",
        _ => ""
    };

    private string GetHopIcon(HopType type) => type switch
    {
        HopType.Client => "üñ•Ô∏è",
        HopType.WirelessClient => "üíª",
        HopType.Switch => "üîÄ",
        HopType.AccessPoint => "üì∂",
        HopType.Gateway => "üåê",
        HopType.Server => "üñ•Ô∏è",
        _ => "‚Ä¢"
    };

    /// <summary>
    /// Render a device icon for the path hop, falling back to emoji if no icon available
    /// </summary>
    private RenderFragment GetHopIconMarkup(NetworkHop hop) => builder =>
    {
        var model = hop.DeviceModel;

        // Show device icons for any UniFi device with a product-style model name (contains dash)
        // This covers switches, APs, gateways, cellular modems, etc.
        if (!string.IsNullOrEmpty(model) && model.Contains('-'))
        {
            var iconPath = DeviceIcon.GetIconPath(model);
            if (iconPath != null)
            {
                builder.OpenElement(0, "img");
                builder.AddAttribute(1, "src", iconPath);
                builder.AddAttribute(2, "alt", model);
                builder.AddAttribute(3, "class", "device-icon device-icon-md");
                builder.AddAttribute(4, "loading", "lazy");
                builder.AddAttribute(5, "onerror", "this.style.display='none';this.nextSibling.style.display='inline'");
                builder.CloseElement();
                // Fallback span (hidden by default)
                builder.OpenElement(6, "span");
                builder.AddAttribute(7, "style", "display:none");
                builder.AddContent(8, GetHopIcon(hop.Type));
                builder.CloseElement();
                return;
            }
        }

        // Fallback to emoji
        builder.AddContent(0, GetHopIcon(hop.Type));
    };
}
