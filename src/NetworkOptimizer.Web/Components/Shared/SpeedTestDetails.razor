@using NetworkOptimizer.Storage.Models
@using NetworkOptimizer.UniFi
@using NetworkOptimizer.UniFi.Models
@using NetworkOptimizer.Web.Services
@using NetworkOptimizer.Web.Components.Shared
@implements IDisposable

<div class="speed-results">
    @if (DownloadMbps > 0)
    {
        <div class="speed-result download">
            <div class="speed-icon">
                <svg viewBox="0 0 24 24" width="32" height="32">
                    <path d="M12 4v12m0 0l-4-4m4 4l4-4M5 18h14" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </div>
            <div class="speed-details">
                <div class="speed-label">From Device <span class="tooltip-icon tooltip-icon-sm" data-tooltip="Data transferred from the tested device to this server">?</span></div>
                <div class="speed-value">@DownloadMbps.ToString("F1") <span class="speed-unit">Mbps</span></div>
                <div class="speed-meta">@FormatBytes(DownloadBytes) transferred</div>
            </div>
        </div>
    }
    @if (UploadMbps > 0)
    {
        <div class="speed-result upload">
            <div class="speed-icon">
                <svg viewBox="0 0 24 24" width="32" height="32">
                    <path d="M12 20V8m0 0l4 4m-4-4l-4 4M5 6h14" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </div>
            <div class="speed-details">
                <div class="speed-label">To Device <span class="tooltip-icon tooltip-icon-sm" data-tooltip="Data transferred to the tested device from this server">?</span></div>
                <div class="speed-value">@UploadMbps.ToString("F1") <span class="speed-unit">Mbps</span></div>
                <div class="speed-meta">@FormatBytes(UploadBytes) transferred</div>
            </div>
        </div>
    }
</div>
@if (DownloadRetransmits > 0 || UploadRetransmits > 0)
{
    <div class="retransmits-info">
        <small>Retransmits: @DownloadRetransmits from / @UploadRetransmits to</small>
    </div>
}
<div class="test-details">
    <span>Device: @DeviceName (@DeviceHost)</span>
    <span>Duration: @DurationSeconds seconds</span>
    <span>Streams: @ParallelStreams parallel</span>
    <span>Time: @TestTime.ToLocalTime().ToString("g")</span>
    @if (OnDelete.HasDelegate && Result != null)
    {
        <span class="delete-action">
            <button class="btn-link-danger" @onclick="HandleDelete" disabled="@_deleting" data-tooltip="Delete this result">
                @if (_deleting)
                {
                    <span class="spinner-sm"></span>
                }
                else
                {
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
                    </svg>
                }
            </button>
        </span>
    }
</div>

@if (PathAnalysis != null)
{
    <div class="path-analysis">
        @if (PathAnalysis.Path.IsValid)
        {
            <div class="path-summary">
                <div class="path-max-speed">
                    <span class="speed-value">@FormatSpeed(PathAnalysis.Path.TheoreticalMaxMbps)</span>
                    <span class="speed-label">max</span>
                </div>
                <div class="efficiency-grades">
                    @if (DownloadMbps > 0)
                    {
                        <div class="grade-item">
                            <span class="grade-badge @GetGradeClass(PathAnalysis.FromDeviceGrade)" data-tooltip="From device to server">
                                ‚Üì @PathAnalysis.FromDeviceEfficiencyPercent.ToString("F0")%
                            </span>
                        </div>
                    }
                    @if (UploadMbps > 0)
                    {
                        <div class="grade-item">
                            <span class="grade-badge @GetGradeClass(PathAnalysis.ToDeviceGrade)" data-tooltip="From server to device">
                                ‚Üë @PathAnalysis.ToDeviceEfficiencyPercent.ToString("F0")%
                            </span>
                        </div>
                    }
                </div>
            </div>

            @if (PathAnalysis.Path.Hops.Count > 0)
            {
                <div class="path-visualization">
                    @for (var i = 0; i < PathAnalysis.Path.Hops.Count; i++)
                    {
                        var hop = PathAnalysis.Path.Hops[i];
                        var deviceTooltip = GetDeviceTooltip(hop);
                        @* Only add data-tooltip for UniFi devices (those with tooltip content) *@
                        @if (!string.IsNullOrEmpty(deviceTooltip))
                        {
                            <div class="path-hop @(hop.IsBottleneck ? "bottleneck" : "") @GetHopTypeClass(hop.Type)" data-tooltip="@deviceTooltip">
                                <span class="hop-icon">@GetHopIconMarkup(hop)</span>
                                <span class="hop-name">@hop.DeviceName</span>
                            </div>
                        }
                        else
                        {
                            <div class="path-hop @(hop.IsBottleneck ? "bottleneck" : "") @GetHopTypeClass(hop.Type)">
                                <span class="hop-icon">@GetHopIconMarkup(hop)</span>
                                <span class="hop-name">@hop.DeviceName</span>
                            </div>
                        }
                        @if (i < PathAnalysis.Path.Hops.Count - 1)
                        {
                            @* Speed goes on the connector (link between devices) *@
                            @* Use next hop's ingress speed (the link TO the next device) *@
                            var nextHop = PathAnalysis.Path.Hops[i + 1];
                            var linkSpeed = nextHop.IngressSpeedMbps > 0 ? nextHop.IngressSpeedMbps : hop.EgressSpeedMbps;
                            @* Mark as bottleneck if this link's speed equals the path minimum and there's a real bottleneck *@
                            var isBottleneckLink = PathAnalysis.Path.HasRealBottleneck &&
                                                   linkSpeed > 0 &&
                                                   linkSpeed == PathAnalysis.Path.TheoreticalMaxMbps;
                            @* Check if this link is wireless (current hop egress or next hop ingress) *@
                            var isWirelessLink = hop.IsWirelessEgress || nextHop.IsWirelessIngress;
                            <div class="path-connector @(isBottleneckLink ? "bottleneck" : "") @(isWirelessLink ? "wireless" : "")">
                                @if (isWirelessLink)
                                {
                                    var wifiTooltip = GetWifiTooltip(hop, nextHop);
                                    <span class="wireless-icon" data-tooltip="@wifiTooltip">üì∂</span>
                                }
                                <span class="connector-line"></span>
                                @if (linkSpeed > 0)
                                {
                                    <span class="connector-speed">@FormatSpeed(linkSpeed)</span>
                                }
                            </div>
                        }
                    }
                </div>
            }

            @if (PathAnalysis.Path.HasRealBottleneck && !string.IsNullOrEmpty(PathAnalysis.Path.BottleneckDescription))
            {
                <div class="bottleneck-warning">
                    ‚ö†Ô∏è @PathAnalysis.Path.BottleneckDescription
                </div>
            }

            @if (PathAnalysis.Path.RequiresRouting && !PathAnalysis.Path.IsExternalPath)
            {
                <div class="routing-badge">
                    üîÄ Inter-VLAN via @(PathAnalysis.Path.GatewayDevice ?? "gateway")
                </div>
            }
        }
        else
        {
            <div class="path-error">
                @(PathAnalysis.Path.ErrorMessage ?? "Path analysis unavailable")
            </div>
        }

        @{
            // Filter out misleading messages when one direction has 0 Mbps (wasn't tested)
            var hasZeroDirection = DownloadMbps == 0 || UploadMbps == 0;
            var filteredInsights = hasZeroDirection
                ? PathAnalysis.Insights.Where(i => !i.Contains("Performance below expected", StringComparison.OrdinalIgnoreCase))
                : PathAnalysis.Insights;
            var filteredRecs = hasZeroDirection
                ? PathAnalysis.Recommendations.Where(r => !r.Contains("asymmetry", StringComparison.OrdinalIgnoreCase))
                : PathAnalysis.Recommendations;
        }
        @if (filteredInsights.Any() || filteredRecs.Any())
        {
            <div class="path-notes">
                @foreach (var insight in filteredInsights)
                {
                    <div class="note insight">üí° @insight</div>
                }
                @foreach (var rec in filteredRecs)
                {
                    <div class="note recommendation">üìà @rec</div>
                }
            </div>
        }
    </div>
}

@code {
    [Parameter] public double DownloadMbps { get; set; }
    [Parameter] public double UploadMbps { get; set; }
    [Parameter] public long DownloadBytes { get; set; }
    [Parameter] public long UploadBytes { get; set; }
    [Parameter] public int DownloadRetransmits { get; set; }
    [Parameter] public int UploadRetransmits { get; set; }
    [Parameter] public string DeviceName { get; set; } = "";
    [Parameter] public string DeviceHost { get; set; } = "";
    [Parameter] public int DurationSeconds { get; set; }
    [Parameter] public int ParallelStreams { get; set; }
    [Parameter] public DateTime TestTime { get; set; }

    /// <summary>
    /// Path analysis result (set automatically when using Result parameter)
    /// </summary>
    [Parameter] public PathAnalysisResult? PathAnalysis { get; set; }

    /// <summary>
    /// Convenience parameter to set all values from an Iperf3Result
    /// </summary>
    [Parameter] public Iperf3Result? Result { get; set; }

    /// <summary>
    /// Convenience parameter to set all values from a GatewaySpeedTestResult
    /// </summary>
    [Parameter] public GatewaySpeedTestResult? GatewayResult { get; set; }

    /// <summary>
    /// Callback invoked when the user confirms deletion.
    /// If not provided, the delete button is hidden.
    /// </summary>
    [Parameter] public EventCallback<int> OnDelete { get; set; }

    // Track previous Result ID to detect when Result changes
    private int? _previousResultId;

    // Delete state
    private bool _deleting;
    private bool _disposed;

    protected override void OnParametersSet()
    {
        if (Result != null)
        {
            // Detect if Result changed (different test)
            bool resultChanged = _previousResultId != Result.Id;
            _previousResultId = Result.Id;

            DownloadMbps = Result.DownloadMbps;
            UploadMbps = Result.UploadMbps;
            DownloadBytes = Result.DownloadBytes;
            UploadBytes = Result.UploadBytes;
            DownloadRetransmits = Result.DownloadRetransmits;
            UploadRetransmits = Result.UploadRetransmits;
            DeviceName = Result.DeviceName ?? "";
            DeviceHost = Result.DeviceHost;
            DurationSeconds = Result.DurationSeconds;
            ParallelStreams = Result.ParallelStreams;
            TestTime = Result.TestTime;

            // Sync PathAnalysis from Result when Result changes
            // This ensures we don't show stale analysis from a previous test
            if (resultChanged)
            {
                PathAnalysis = Result.PathAnalysis;
            }
            else
            {
                // Only use Result.PathAnalysis if no separate PathAnalysis was passed
                PathAnalysis ??= Result.PathAnalysis;
            }
        }
        else if (GatewayResult != null)
        {
            DownloadMbps = GatewayResult.DownloadMbps;
            UploadMbps = GatewayResult.UploadMbps;
            DownloadBytes = GatewayResult.DownloadBytes;
            UploadBytes = GatewayResult.UploadBytes;
            DownloadRetransmits = GatewayResult.DownloadRetransmits;
            UploadRetransmits = GatewayResult.UploadRetransmits;
            DeviceName = "Gateway";
            DeviceHost = GatewayResult.GatewayHost ?? "";
            DurationSeconds = GatewayResult.DurationSeconds;
            ParallelStreams = GatewayResult.ParallelStreams;
            TestTime = GatewayResult.TestTime;
        }
    }

    private string FormatBytes(long bytes)
    {
        if (bytes < 1024)
            return $"{bytes} B";
        if (bytes < 1024 * 1024)
            return $"{bytes / 1024.0:F1} KB";
        if (bytes < 1024 * 1024 * 1024)
            return $"{bytes / (1024.0 * 1024.0):F1} MB";
        return $"{bytes / (1024.0 * 1024.0 * 1024.0):F2} GB";
    }

    private string FormatSpeed(int mbps)
    {
        if (mbps >= 1000)
        {
            var gbps = mbps / 1000.0;
            return gbps % 1 == 0 ? $"{(int)gbps} Gbps" : $"{gbps:F1} Gbps";
        }
        return $"{mbps} Mbps";
    }

    private string GetGradeClass(PerformanceGrade grade) => grade switch
    {
        PerformanceGrade.Excellent => "grade-excellent",
        PerformanceGrade.Good => "grade-good",
        PerformanceGrade.Fair => "grade-fair",
        PerformanceGrade.Poor => "grade-poor",
        PerformanceGrade.Critical => "grade-critical",
        _ => ""
    };

    private string GetHopTypeClass(HopType type) => type switch
    {
        HopType.Client => "hop-client",
        HopType.WirelessClient => "hop-client",
        HopType.Switch => "hop-switch",
        HopType.AccessPoint => "hop-ap",
        HopType.Gateway => "hop-gateway",
        HopType.Server => "hop-server",
        HopType.Teleport => "hop-teleport",
        HopType.Tailscale => "hop-tailscale",
        HopType.Wan => "hop-wan",
        HopType.Vpn => "hop-vpn",
        _ => ""
    };

    /// <summary>
    /// Get device tooltip showing type, model, and firmware for UniFi devices
    /// </summary>
    private string? GetDeviceTooltip(NetworkHop hop)
    {
        // Only show tooltip for UniFi devices (those with a model)
        if (string.IsNullOrEmpty(hop.DeviceModel))
            return null;

        var deviceType = GetDeviceTypeName(hop.Type);
        var lines = new List<string>();

        lines.Add($"<div class='device-tooltip-row'><span class='device-tooltip-label'>Type:</span> {deviceType}</div>");
        lines.Add($"<div class='device-tooltip-row'><span class='device-tooltip-label'>Model:</span> {hop.DeviceModel}</div>");

        if (!string.IsNullOrEmpty(hop.DeviceFirmware))
        {
            lines.Add($"<div class='device-tooltip-row'><span class='device-tooltip-label'>Firmware:</span> {hop.DeviceFirmware}</div>");
        }

        return string.Join("", lines);
    }

    private string GetDeviceTypeName(HopType type) => type switch
    {
        HopType.Switch => "Switch",
        HopType.AccessPoint => "Access Point",
        HopType.Gateway => "Gateway",
        HopType.Server => "Server",
        HopType.Client => "Client",
        HopType.WirelessClient => "Wireless Client",
        HopType.Teleport => "Teleport VPN",
        HopType.Tailscale => "Tailscale VPN",
        HopType.Wan => "WAN",
        HopType.Vpn => "VPN",
        _ => "Device"
    };

    private string GetHopIcon(HopType type) => type switch
    {
        HopType.Client => "üñ•Ô∏è",
        HopType.WirelessClient => "üíª",
        HopType.Switch => "üîÄ",
        HopType.AccessPoint => "üì∂",
        HopType.Gateway => "üåê",
        HopType.Server => "üñ•Ô∏è",
        HopType.Teleport => "üîí",
        HopType.Tailscale => "üîí",
        HopType.Wan => "üåê",
        HopType.Vpn => "üîí",
        _ => "‚Ä¢"
    };

    /// <summary>
    /// Get Wi-Fi signal tooltip content from the hop or Result
    /// </summary>
    private string GetWifiTooltip(NetworkHop hop, NetworkHop nextHop)
    {
        // Determine if this is the client's wireless connection (first hop is WirelessClient)
        // or a mesh/bridge wireless link
        var isClientWireless = hop.Type == HopType.WirelessClient || nextHop.Type == HopType.WirelessClient;

        // Get band from hop (mesh) or result (client)
        string? band = null;
        if (hop.IsWirelessEgress && !string.IsNullOrEmpty(hop.WirelessEgressBand))
            band = hop.WirelessEgressBand;
        else if (nextHop.IsWirelessIngress && !string.IsNullOrEmpty(nextHop.WirelessIngressBand))
            band = nextHop.WirelessIngressBand;

        // For client wireless, also show signal/noise from Result
        if (isClientWireless && Result != null)
        {
            // Check for MLO (Multi-Link Operation) - use unified styling
            if (Result.WifiIsMlo && !string.IsNullOrEmpty(Result.WifiMloLinksJson))
            {
                return BuildMloTooltip();
            }

            // Single-link wireless - use same styled format as MLO
            var lines = new List<string>();
            var clientBand = !string.IsNullOrEmpty(Result.WifiRadio) ? Result.WifiRadio : band;

            // Header with protocol
            if (!string.IsNullOrEmpty(Result.WifiRadioProto))
                lines.Add($"<div class='wifi-tooltip-header'>Wi-Fi {FormatRadioProto(Result.WifiRadioProto, clientBand)}</div>");

            // RX/TX speeds (RX first = "from device", TX = "to device")
            if (Result.WifiTxRateKbps.HasValue || Result.WifiRxRateKbps.HasValue)
            {
                var speedParts = new List<string>();
                if (Result.WifiRxRateKbps.HasValue && Result.WifiRxRateKbps.Value > 0)
                    speedParts.Add($"<span class='wifi-speed-rx'>RX {Result.WifiRxRateKbps.Value / 1000} Mbps</span>");
                if (Result.WifiTxRateKbps.HasValue && Result.WifiTxRateKbps.Value > 0)
                    speedParts.Add($"<span class='wifi-speed-tx'>TX {Result.WifiTxRateKbps.Value / 1000} Mbps</span>");
                if (speedParts.Count > 0)
                    lines.Add($"<div class='wifi-tooltip-row wifi-tooltip-speed'>{string.Join(" ¬∑ ", speedParts)}</div>");
            }

            // Link info with band badge
            if (!string.IsNullOrEmpty(clientBand) || Result.WifiChannel.HasValue)
            {
                var linkParts = new List<string>();
                if (!string.IsNullOrEmpty(clientBand))
                    linkParts.Add($"<span class='wifi-band-badge wifi-band-{clientBand}'>{FormatRadioBand(clientBand)}</span>");
                if (Result.WifiChannel.HasValue)
                    linkParts.Add($"Ch {Result.WifiChannel.Value}");
                lines.Add($"<div class='wifi-tooltip-link'>{string.Join(" ", linkParts)}</div>");
            }

            // Signal line
            if (Result.WifiSignalDbm.HasValue)
            {
                var sigParts = new List<string> { $"{Result.WifiSignalDbm.Value} dBm" };
                if (Result.WifiNoiseDbm.HasValue)
                    sigParts.Add($"SNR {Result.WifiSignalDbm.Value - Result.WifiNoiseDbm.Value} dB");
                lines.Add($"<div class='wifi-tooltip-link-signal'>{string.Join(" ¬∑ ", sigParts)}</div>");
            }

            return lines.Count > 0 ? string.Join("", lines) : "Wireless connection";
        }

        // For mesh/bridge wireless - use same styled format
        var meshHop = hop.IsWirelessEgress ? hop : nextHop;
        var lines2 = new List<string>();

        lines2.Add("<div class='wifi-tooltip-header'>Wireless Mesh</div>");

        // RX/TX speeds (RX first = "from device", TX = "to device")
        if (meshHop.WirelessTxRateMbps.HasValue || meshHop.WirelessRxRateMbps.HasValue)
        {
            var speedParts = new List<string>();
            if (meshHop.WirelessRxRateMbps.HasValue)
                speedParts.Add($"<span class='wifi-speed-rx'>RX {meshHop.WirelessRxRateMbps.Value} Mbps</span>");
            if (meshHop.WirelessTxRateMbps.HasValue)
                speedParts.Add($"<span class='wifi-speed-tx'>TX {meshHop.WirelessTxRateMbps.Value} Mbps</span>");
            lines2.Add($"<div class='wifi-tooltip-row wifi-tooltip-speed'>{string.Join(" ¬∑ ", speedParts)}</div>");
        }

        // Link info with band badge
        if (!string.IsNullOrEmpty(band) || meshHop.WirelessChannel.HasValue)
        {
            var linkParts = new List<string>();
            if (!string.IsNullOrEmpty(band))
                linkParts.Add($"<span class='wifi-band-badge wifi-band-{band}'>{FormatRadioBand(band)}</span>");
            if (meshHop.WirelessChannel.HasValue)
                linkParts.Add($"Ch {meshHop.WirelessChannel.Value}");
            lines2.Add($"<div class='wifi-tooltip-link'>{string.Join(" ", linkParts)}</div>");
        }

        // Signal line
        if (meshHop.WirelessSignalDbm.HasValue)
        {
            var sigParts = new List<string> { $"{meshHop.WirelessSignalDbm.Value} dBm" };
            if (meshHop.WirelessNoiseDbm.HasValue)
                sigParts.Add($"SNR {meshHop.WirelessSignalDbm.Value - meshHop.WirelessNoiseDbm.Value} dB");
            lines2.Add($"<div class='wifi-tooltip-link-signal'>{string.Join(" ¬∑ ", sigParts)}</div>");
        }

        return lines2.Count > 1 ? string.Join("", lines2) : "Wireless mesh";
    }

    /// <summary>
    /// Build tooltip content for MLO (Multi-Link Operation) Wi-Fi 7 connections
    /// </summary>
    private string BuildMloTooltip()
    {
        if (Result == null || string.IsNullOrEmpty(Result.WifiMloLinksJson))
            return "Wi-Fi 7 MLO";

        try
        {
            var links = System.Text.Json.JsonSerializer.Deserialize<List<MloLinkData>>(Result.WifiMloLinksJson);
            if (links == null || links.Count == 0)
                return "Wi-Fi 7 MLO";

            var lines = new List<string>();

            // Header with Wi-Fi 7 MLO badge
            lines.Add("<div class='wifi-tooltip-header'>Wi-Fi 7 (be) ¬∑ MLO</div>");

            // Sum link speeds
            var totalTxMbps = links.Where(l => l.txRate.HasValue).Sum(l => l.txRate!.Value / 1000.0);
            var totalRxMbps = links.Where(l => l.rxRate.HasValue).Sum(l => l.rxRate!.Value / 1000.0);

            if (totalTxMbps > 0 || totalRxMbps > 0)
            {
                var speedParts = new List<string>();
                if (totalRxMbps > 0) speedParts.Add($"<span class='wifi-speed-rx'>RX {totalRxMbps:F0} Mbps</span>");
                if (totalTxMbps > 0) speedParts.Add($"<span class='wifi-speed-tx'>TX {totalTxMbps:F0} Mbps</span>");
                lines.Add($"<div class='wifi-tooltip-row wifi-tooltip-speed'>{string.Join(" ¬∑ ", speedParts)}</div>");
            }

            // Divider
            lines.Add("<div class='wifi-tooltip-divider'></div>");

            // Each link
            foreach (var link in links.OrderByDescending(l => l.channelWidth ?? 0))
            {
                var linkParts = new List<string>();

                // Band badge
                if (!string.IsNullOrEmpty(link.radio))
                    linkParts.Add($"<span class='wifi-band-badge wifi-band-{link.radio}'>{FormatRadioBand(link.radio)}</span>");

                // Channel/width
                if (link.channel.HasValue)
                {
                    var chInfo = $"Ch {link.channel.Value}";
                    if (link.channelWidth.HasValue)
                        chInfo += $" ({link.channelWidth.Value} MHz)";
                    linkParts.Add(chInfo);
                }

                lines.Add($"<div class='wifi-tooltip-link'>{string.Join(" ", linkParts)}</div>");

                // Per-link RX/TX rates (RX first = "from device", TX = "to device")
                if (link.txRate.HasValue || link.rxRate.HasValue)
                {
                    var linkSpeedParts = new List<string>();
                    if (link.rxRate.HasValue)
                        linkSpeedParts.Add($"<span class='wifi-speed-rx'>RX {link.rxRate.Value / 1000} Mbps</span>");
                    if (link.txRate.HasValue)
                        linkSpeedParts.Add($"<span class='wifi-speed-tx'>TX {link.txRate.Value / 1000} Mbps</span>");
                    lines.Add($"<div class='wifi-tooltip-link-speed'>{string.Join(" ¬∑ ", linkSpeedParts)}</div>");
                }

                // Signal for this link
                if (link.signal.HasValue)
                {
                    var sigParts = new List<string> { $"{link.signal.Value} dBm" };
                    if (link.signal.HasValue && link.noise.HasValue)
                        sigParts.Add($"SNR {link.signal.Value - link.noise.Value} dB");
                    lines.Add($"<div class='wifi-tooltip-link-signal'>{string.Join(" ¬∑ ", sigParts)}</div>");
                }
            }

            return string.Join("", lines);
        }
        catch
        {
            return "Wi-Fi 7 MLO";
        }
    }

    // DTO for deserializing MLO link JSON
    private record MloLinkData(
        string? radio,
        int? channel,
        int? channelWidth,
        int? signal,
        int? noise,
        long? txRate,
        long? rxRate
    );

    private string FormatRadioBand(string? radio) => RadioFormatHelper.FormatBand(radio);

    private string FormatRadioProto(string? proto, string? radio = null) =>
        RadioFormatHelper.FormatProtocolSuffix(proto, radio);

    /// <summary>
    /// Render a device icon for the path hop, falling back to emoji if no icon available
    /// </summary>
    private RenderFragment GetHopIconMarkup(NetworkHop hop) => builder =>
    {
        // VPN hops get custom SVG icons
        if (hop.Type == HopType.Teleport)
        {
            builder.OpenElement(0, "svg");
            builder.AddAttribute(1, "viewBox", "0 0 20 20");
            builder.AddAttribute(2, "width", "24");
            builder.AddAttribute(3, "height", "24");
            builder.AddAttribute(4, "class", "vpn-icon teleport-icon");
            builder.AddMarkupContent(5, @"<path fill-rule=""evenodd"" clip-rule=""evenodd"" d=""M5.111 7.255c-.125-1.072-.318-1.952-.544-2.55-.115-.3-.227-.502-.322-.618a.555.555 0 0 0-.066-.07.897.897 0 0 0-.183.243c-.156.27-.312.693-.45 1.26-.275 1.127-.45 2.708-.45 4.474 0 1.765.175 3.347.45 4.473.138.567.294.99.45 1.26.086.15.15.216.183.244a.558.558 0 0 0 .068-.072c.096-.12.21-.324.324-.63.228-.606.422-1.497.545-2.582a.5.5 0 1 1 .994.114c-.129 1.126-.335 2.107-.603 2.82-.133.354-.291.67-.483.908-.188.231-.47.459-.845.459-.51 0-.848-.41-1.05-.761-.223-.388-.407-.915-.555-1.523-.299-1.224-.478-2.89-.478-4.71 0-1.821.18-3.486.478-4.71.148-.609.332-1.136.555-1.523C3.331 3.41 3.67 3 4.18 3c.373 0 .653.224.84.454.192.235.35.548.483.898.267.704.473 1.673.603 2.788a.5.5 0 0 1-.994.115Zm-.96 8.736-.003.001h.003ZM15.543 4.706c-.227.597-.42 1.477-.545 2.55a.5.5 0 0 1-.993-.116c.13-1.115.336-2.084.603-2.788.132-.35.29-.663.482-.898.187-.23.467-.454.84-.454.511 0 .848.41 1.05.76.223.388.407.915.555 1.524.299 1.224.478 2.889.478 4.71 0 1.82-.18 3.486-.478 4.71-.148.608-.332 1.135-.555 1.523-.202.35-.539.76-1.05.76-.375 0-.656-.227-.844-.458-.193-.238-.351-.554-.484-.908-.268-.713-.474-1.694-.603-2.82a.5.5 0 1 1 .994-.114c.124 1.085.317 1.976.545 2.582.115.306.228.51.324.63a.562.562 0 0 0 .068.072.898.898 0 0 0 .183-.244c.156-.27.313-.693.45-1.26.275-1.126.45-2.708.45-4.473 0-1.766-.175-3.347-.45-4.474-.137-.567-.294-.99-.45-1.26a.896.896 0 0 0-.183-.243.554.554 0 0 0-.066.07c-.095.116-.207.318-.321.619Zm.418 11.286h-.002.002ZM7.557 9.684a.5.5 0 0 0 0 .707l2.122 2.122a.5.5 0 0 0 .707 0l2.123-2.122a.5.5 0 0 0 0-.707L10.386 7.56a.5.5 0 0 0-.707 0L7.557 9.684Zm1.06.353 1.416 1.416 1.415-1.416-1.415-1.415-1.416 1.415Z"" fill=""currentColor""/>");
            builder.CloseElement();
            return;
        }

        if (hop.Type == HopType.Tailscale)
        {
            builder.OpenElement(0, "svg");
            builder.AddAttribute(1, "viewBox", "0 0 20 20");
            builder.AddAttribute(2, "width", "24");
            builder.AddAttribute(3, "height", "24");
            builder.AddAttribute(4, "class", "vpn-icon tailscale-icon");
            // Official Tailscale logo - 3x3 dot grid: middle row + center bottom solid, corners faded
            builder.AddMarkupContent(5, @"<ellipse cx=""2.45"" cy=""10.18"" rx=""2.45"" ry=""2.44"" fill=""currentColor""/><ellipse cx=""9.79"" cy=""10.18"" rx=""2.45"" ry=""2.44"" fill=""currentColor""/><ellipse cx=""17.13"" cy=""10.18"" rx=""2.45"" ry=""2.44"" fill=""currentColor""/><ellipse cx=""9.79"" cy=""17.51"" rx=""2.45"" ry=""2.44"" fill=""currentColor""/><ellipse opacity=""0.2"" cx=""2.45"" cy=""2.86"" rx=""2.45"" ry=""2.44"" fill=""currentColor""/><ellipse opacity=""0.2"" cx=""9.79"" cy=""2.86"" rx=""2.45"" ry=""2.44"" fill=""currentColor""/><ellipse opacity=""0.2"" cx=""17.13"" cy=""2.86"" rx=""2.45"" ry=""2.44"" fill=""currentColor""/><ellipse opacity=""0.2"" cx=""2.45"" cy=""17.51"" rx=""2.45"" ry=""2.44"" fill=""currentColor""/><ellipse opacity=""0.2"" cx=""17.13"" cy=""17.51"" rx=""2.45"" ry=""2.44"" fill=""currentColor""/>");
            builder.CloseElement();
            return;
        }

        if (hop.Type == HopType.Vpn)
        {
            builder.OpenElement(0, "img");
            builder.AddAttribute(1, "src", "/icons/shield-v2.png");
            builder.AddAttribute(2, "alt", "VPN");
            builder.AddAttribute(3, "class", "vpn-icon vpn-shield-icon");
            builder.CloseElement();
            return;
        }

        var model = hop.DeviceModel;

        // Show device icons for any device with a model name - onerror falls back to emoji
        if (!string.IsNullOrEmpty(model))
        {
            var iconPath = DeviceIcon.GetIconPath(model);
            if (iconPath != null)
            {
                builder.OpenElement(0, "img");
                builder.AddAttribute(1, "src", iconPath);
                builder.AddAttribute(2, "alt", model);
                builder.AddAttribute(3, "class", "device-icon device-icon-md");
                builder.AddAttribute(4, "loading", "lazy");
                builder.AddAttribute(5, "onerror", "this.style.display='none';this.nextSibling.style.display='inline'");
                builder.CloseElement();
                // Fallback span (hidden by default)
                builder.OpenElement(6, "span");
                builder.AddAttribute(7, "style", "display:none");
                builder.AddContent(8, GetHopIcon(hop.Type));
                builder.CloseElement();
                return;
            }
        }

        // Fallback to emoji
        builder.AddContent(0, GetHopIcon(hop.Type));
    };

    private async Task HandleDelete()
    {
        if (Result == null) return;

        _deleting = true;
        try
        {
            await OnDelete.InvokeAsync(Result.Id);
        }
        finally
        {
            // Only reset if component is still mounted (delete may have removed us from DOM)
            if (!_disposed)
            {
                _deleting = false;
            }
        }
    }

    public void Dispose()
    {
        _disposed = true;
    }
}
